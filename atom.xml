<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Creeper's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://creeperyang.github.io//"/>
  <updated>2015-07-02T15:00:48.000Z</updated>
  <id>http://creeperyang.github.io//</id>
  
  <author>
    <name><![CDATA[Creeper]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[前端问题集锦]]></title>
    <link href="http://creeperyang.github.io/2015/04/frontend-questions-and-answers/"/>
    <id>http://creeperyang.github.io/2015/04/frontend-questions-and-answers/</id>
    <published>2015-04-06T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>关于前端，工作和学习过程中遇到过许多问题，也解答过许多别人的问题。这篇博客权当一个记录，记录一些有价值的问题。</p>
<!--view-break-->
<h2 id="1-_JavaScript语法相关问题">1. JavaScript语法相关问题</h2><h3 id="1-1_对象字面值的点操作符问题">1.1 对象字面值的点操作符问题</h3><ul>
<li><p>问题： </p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a:<span class="number">1</span>&#125;.a <span class="comment">// Uncaught SyntaxError: Unexpected token .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123;a:<span class="number">1</span>&#125;.a) <span class="comment">// 或</span></span><br><span class="line">(&#123;a:<span class="number">1</span>&#125;).a</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<p>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals" target="_blank" rel="external">MDN: Object literals</a></p>
<blockquote>
<p>An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces ({}). You should not use an object literal at the beginning of a statement. This will lead to an error or not behave as you expect, because the { will be interpreted as the beginning of a block.</p>
</blockquote>
<p>  简单说，就是声明对象字面值时，语句开头不应该用<code>{</code>，因为js解释器会认为这是语句块（<code>block</code>）的开始。</p>
</li>
</ul>
<h3 id="1-2_字符串字面值的点操作符问题">1.2 字符串字面值的点操作符问题</h3><ul>
<li><p>问题：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>; num.toFixed(<span class="number">2</span>) <span class="comment">// &gt;&gt; "123.00"</span></span><br><span class="line"><span class="number">123.</span>toFixed(<span class="number">2</span>) <span class="comment">// Uncaught SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">123</span>).toFixed(<span class="number">2</span>) <span class="comment">// &gt;&gt; "123.00"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<p>  很简单，js解释器会默认<code>.</code>应该是小数点而不是点操作符。</p>
</li>
</ul>
<h3 id="1-3_对象字面值的问题(updated:_2015-04-13)">1.3 对象字面值的问题(<em>updated: 2015-04-13</em>)</h3><ul>
<li><p>问题： 在（chrome）控制台输入以下代码会发生什么？</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: <span class="string">"mc"</span>, id: <span class="number">1</span> &#125; <span class="comment">// Uncaught SyntaxError: Unexpected token :</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; name: <span class="string">"mc"</span>, id: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
<p>  同<strong>1.1</strong>。但这里有个问题，<code>{name: &quot;mc&quot;}</code>是不会报错的。这行代码等同于<code>name: &quot;mc&quot;</code>，并返回一个字符串<code>&quot;mc&quot;</code>。具体colon（<code>:</code>）到底代表了什么操作，目前未知。</p>
</li>
</ul>
<h3 id="1-4_连等赋值问题(updated:_2015-04-23)">1.4 连等赋值问题(<em>updated: 2015-04-23</em>)</h3><ul>
<li><p>问题： javascript 连等赋值问题</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;n: <span class="number">1</span>&#125;;  </span><br><span class="line"><span class="keyword">var</span> b = a; </span><br><span class="line">a.x = a = &#123;n: <span class="number">2</span>&#125;;  </span><br><span class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">// --&gt; undefined  </span></span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">// --&gt; &#123;n:2&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原因： </p>
<p>  我们可以先尝试交换下连等赋值顺序（<code>a = a.x = {n: 2};</code>），可以发现输出不变，即顺序不影响结果。</p>
<p>  那么现在来解释对象连等赋值的问题：按照<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.13" target="_blank" rel="external">ecma-262规范</a>，题中连等赋值等价于<br>  <code>a.x = (a = {n: 2});</code>，按优先获取左引用（<code>lref</code>），然后获取右引用（<code>rref</code>）的顺序，<code>a.x</code>和<code>a</code>中的a都指向了<code>{n: 1}</code>。至此，至关重要或者说最迷惑的一步明确。<code>(a = {n: 2})</code>执行完成后，变量<code>a</code>指向<code>{n: 2}</code>，并返回<code>{n: 2}</code>;接着执行<code>a.x = {n: 2}</code>，这里的<code>a</code>就是<code>b</code>（指向<code>{n: 1}</code>），所以<code>b.x</code>就指向了<code>{n: 2}</code>。</p>
<p>  搜索此题答案时，<a href="http://yanhaijing.com/javascript/2012/04/05/javascript-continuous-assignment-operator/" target="_blank" rel="external">颜海镜的一篇博客</a>关于此题也有讲述，不过没有讲清楚（或许是我没有领会 :P）。</p>
</li>
</ul>
<h3 id="1-5_逗号操作符(updated:_2015-04-29)">1.5 逗号操作符(<em>updated: 2015-04-29</em>)</h3><ul>
<li><p>问题： javascript comma operator，下面的代码返回什么，为什么？</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> temp = &#123;</span><br><span class="line">    x: <span class="number">40</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">(temp.foo, temp.foo)(); <span class="comment">// 20，而不是40</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原因： </p>
<p>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator" target="_blank" rel="external">MDN逗号操作符</a>: The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand.</p>
<p>  即逗号操作符会从左到右计算它的操作数，返回最后一个操作数的值。所以<code>(temp.foo, temp.foo)();</code>等价于<code>var fun = temp.foo; fun();</code>，<code>fun</code>调用时<code>this</code>指向<code>window</code>，所以返回20。</p>
</li>
</ul>
<h2 id="2-_JavaScript内置API相关问题">2. JavaScript内置API相关问题</h2><h3 id="2-1_parseInt的问题(updated:_2015-04-13)">2.1 parseInt的问题(<em>updated: 2015-04-13</em>)</h3><ul>
<li><p>问题： </p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.000008</span>) <span class="comment">// &gt;&gt; 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// &gt;&gt; 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原因：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.000008</span>).toString() <span class="comment">// "0.000008"</span></span><br><span class="line">(<span class="number">0.0000008</span>).toString() <span class="comment">// "8e-7"</span></span><br></pre></td></tr></table></figure>
<p>  <code>parseInt(arg)</code>时会调用<code>arg.toString()</code>。</p>
</li>
</ul>
<hr>
<p>waiting… </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于前端，工作和学习过程中遇到过许多问题，也解答过许多别人的问题。这篇博客权当一个记录，记录一些有价值的问题。</p>
<!--view-break-->
<h2 id="1-_JavaScript语法相关问题">1. JavaScript语法相关问题</h2><h3 id]]>
    </summary>
    
      <category term="questions" scheme="http://creeperyang.github.io/tags/questions/"/>
    
      <category term="问题" scheme="http://creeperyang.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/categories/frontend/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript event loop and timing in-depth]]></title>
    <link href="http://creeperyang.github.io/2015/04/JavaScript-timer/"/>
    <id>http://creeperyang.github.io/2015/04/JavaScript-timer/</id>
    <published>2015-04-06T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>先看一道阿里面试题（来自<a href="http://www.w3cfuns.com/blog-5448978-5404954.html" target="_blank" rel="external">阿里2015春季前端实习校招笔试题</a>）:</p>
<p>对于下列程序运行结果，符合预期的是：</p>
<!--view-break-->
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'time span'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'time span'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout (f1, <span class="number">100</span>);</span><br><span class="line">setTimeout (f2, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForMs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt; n) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">waitForMs(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>A. time span :700.077ms</li>
<li>B. time span :0.066ms</li>
<li>C. time span :500.077ms</li>
<li>D. time span :100.077ms</li>
</ul>
<p>答案是<strong>B</strong>，但为什么？</p>
<h2 id="Concurrency_model_and_Event_Loop">Concurrency model and Event Loop</h2><p>要理解定时器内部怎么工作的，首先要明白 JavaScript 的<strong>Concurrency model and Event Loop(并发模型和事件回环)</strong>。</p>
<p>JavaScript 有一个基于事件回环的并发模型，这与<code>C</code>或<code>Java</code>很不同。</p>
<h3 id="确立几个运行时概念（runtime_concepts）">确立几个运行时概念（runtime concepts）</h3><ul>
<li><strong>Stack</strong>： 栈，函数调用形成帧栈（a stack of frames）。如调用函数A，那么首先第一个包含A的参数和局部变量的frame（frameA）被创建;当A中调用B，包含B的参数和局部变量的frame（frameB）被创建，并push到frameA上面。B<code>return</code>后，frameB从栈中pop出来，当A<code>return</code>后，栈就是空的了。</li>
<li><strong>Heap</strong>： 堆，对象被分配在堆中。</li>
<li><strong>Queue</strong>： 每个 JavaScript runtime 都包含一个消息队列（message queue），即一列要处理的消息。每个消息对应（associated）一个函数。当 stack 是空的，队列中的一个消息就被取出并处理。处理包括调用对应的（associated）那个函数（这会创建栈），当栈再次空了之后，这个处理就结束了。</li>
</ul>
<h3 id="Event_loop">Event loop</h3><p>事件回环（event loop）得名于它的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(queue.waitForMessage())&#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queue.waitForMessage</code>同步等待一个消息到来，如果当前没有消息的话。</p>
<h4 id="“Run-to-completion”">“Run-to-completion”</h4><p>每个消息会在任何其它消息被处理前处理完。</p>
<p>这有很多好处，但会有一个副作用：如果一个消息处理要花很长时间，那么这期间浏览器就不会响应用户交互（点击，滚动等等），即浏览器假死。好的方法是让消息处理过程短，并且可能的话把一个消息分割成若干消息。</p>
<h4 id="Adding_messages">Adding messages</h4><p>在浏览器中，任何时间有事件发生且该事件有监听函数的话，那么一个消息就会被添加。如果没有监听函数，该事件被忽略。</p>
<p>另外，调用<code>setTimeout</code>会在第二个参数指定的时间后添加消息到消息队列。如果此时队列中没有其它消息，那么这个消息会立即处理，如果有其它消息，那么<code>setTimeout</code>消息就必须等到其它消息处理后才会被处理。所以第二个参数指定的是最小时间，而不是保证的精确时间。</p>
<h4 id="Several_Runtime_communicating_together">Several Runtime communicating together</h4><p>web worker 或者跨域的 iframe 有自己对立的堆、栈还有队列。两个不同的 runtime 只能通过<code>postMessage</code>来通信。</p>
<h2 id="JavaScript_is_single-threaded">JavaScript is single-threaded</h2><p><strong>JavaScript是单线程的。</strong></p>
<p>这一段重点讲js是单线程的，或者说从单线程角度来理解js的并发和事件回环。正因为js是单线程的，所以js只能通过事件回环来实现并发。</p>
<p><strong>在浏览器中，每个 window 只有一个js线程。</strong>其它如下载等等都是独立线程的。</p>
<p>既然js是单线程的，那么某段时间js只能执行一段代码，执行这段代码时，会阻塞其它异步事件的处理。这意味着异步事件只能加入消息队列等待处理。</p>
<h2 id="setTimeout与setInterval">setTimeout与setInterval</h2><p>正式来解答开头的题目，一探js定时器的秘密。</p>
<p>当执行<code>setTimeout/setInterval</code>时，js引擎会产生一个消息并添加到消息队列。</p>
<ol>
<li><p>当是<code>setTimeout</code>时，如<code>setTimeout(fn, delay)</code></p>
<p> js引擎会在delay毫秒后把消息添加到队列。如果消息队列是空的，那么立即处理消息，执行<code>fn</code>。而题目中，<code>waitForMs</code>会使当前处理过程持续500毫秒，此时两个<code>setTimeout</code>消息都被添加到消息队列中了，会顺序执行（时间间隔几乎为0）。</p>
</li>
<li><p>当是<code>setInterval</code>时，如<code>setInterval(fn, delay)</code></p>
<p> <code>setInterval</code>在怎么执行异步代码上和<code>setTimeout</code>差别很大。假设<code>fn</code>执行时间小于<code>delay</code>，那么<code>setTimeout</code>是可以做到每<code>delay</code>执行一次，但如果<code>fn</code>执行时间很长，或者当前消息处理时间很长，那么<code>fn</code>可能紧贴着执行多次（没有<code>delay</code>）或者执行间隔很长。</p>
</li>
</ol>
<hr>
<p>备注：</p>
<ul>
<li>异步事件： JavaScript 中大多数事件是异步的，如鼠标事件。当异步事件发生时，消息被添加到队列。</li>
<li>同步事件： 有些事件是同步的，事件处理函数会立即执行，而同步时间发生时，也不会添加消息到队列。同步事件有 DOM mutation 以及嵌套的 DOM 事件。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">MDN: Concurrency model and Event Loop</a></li>
<li><a href="http://javascript.info/tutorial/events-and-timing-depth#asynchronous-events" target="_blank" rel="external">Events and timing in-depth</a></li>
<li><a href="http://ejohn.org/blog/how-javascript-timers-work/" target="_blank" rel="external">How JavaScript Timers Work</a></li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>先看一道阿里面试题（来自<a href="http://www.w3cfuns.com/blog-5448978-5404954.html" target="_blank" rel="external">阿里2015春季前端实习校招笔试题</a>）:</p>
<p>对于下列]]>
    </summary>
    
      <category term="event loop" scheme="http://creeperyang.github.io/tags/event-loop/"/>
    
      <category term="setInterval" scheme="http://creeperyang.github.io/tags/setInterval/"/>
    
      <category term="setTimeout" scheme="http://creeperyang.github.io/tags/setTimeout/"/>
    
      <category term="timer" scheme="http://creeperyang.github.io/tags/timer/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/categories/frontend/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从static/dynamic scope来谈JS的作用域]]></title>
    <link href="http://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/"/>
    <id>http://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/</id>
    <published>2015-01-07T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'local'</span>;</span><br><span class="line">    printStr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printStr(); <span class="comment">// 毫无疑问，输出 "global"</span></span><br><span class="line">testScope(); <span class="comment">// 还是输出 "global"</span></span><br></pre></td></tr></table></figure>
<!--view-break-->
<p>在上面一段JS代码中<code>printStr();</code>输出<code>&quot;global&quot;</code>是很自然的，但<code>testScope();</code>仍然输出<code>&quot;global&quot;</code>可能就要让部分（使用其他语言的）人惊讶不解了。本文将从这段代码展开，深入JS的作用域（体系）。</p>
<h2 id="变量、值与作用域">变量、值与作用域</h2><h3 id="从一般意义来理解变量、值与作用域">从一般意义来理解变量、值与作用域</h3><ul>
<li><strong>variable</strong>：变量，就是值的符号名字（symbolic name）。变量的名字叫做标识符（identifier）。如<code>var x = 5;</code>中<code>x</code>就是变量。</li>
<li><strong>value</strong>：值，真实数据，如字符串、数字、对象甚至函数等等。</li>
<li><strong>varaible scope</strong>：<code>name bingding</code>（即变量和值的联系）的作用域，是指在部分程序（<strong>part of a program</strong>，大多数情况就是代码块）内，变量与值的联系是有效的（即变量可以用来引用值）。而在程序的另一部分，该变量可能指向另一个值，或者干脆没有任何绑定。作用域又称为值的可见性。</li>
</ul>
<blockquote>
<p>In computer programming, the scope of a name binding – an association of a name to an entity, such as a variable – is the part of a computer program where the binding is valid: where the name can be used to refer to the entity. In other parts of the program the name may refer to a different entity (it may have a different binding), or to nothing at all (it may be unbound). The scope of a binding is also known as the <strong>visibility</strong> of an entity, particularly in older or more technical literature – this is from the perspective of the referenced entity, not the referencing name. A scope is a part of a program that is or can be the scope for a set of bindings – a precise definition is tricky (see below), but in casual use and in practice largely corresponds to a block, a function, or a file, depending on language and type of entity. The term “scope” is also used to refer to the set of all entities that are visible or names that are valid within a portion of the program or at a given point in a program, which is more correctly referred to as context or environment. <small>—<a href="http://en.wikipedia.org/wiki/Scope_(computer_science" target="_blank" rel="external">http://en.wikipedia.org/wiki/Scope_(computer_science</a>)</small></p>
</blockquote>
<p>（Lexial） scope的明确定义是<em>the portion of source code in which a binding of a name with an entity applies</em>，即scope就是一段源码（代码块），在这段代码内，变量到值的绑定应用。</p>
<h3 id="JavaScript中的变量、值与作用域">JavaScript中的变量、值与作用域</h3><p>在JavaScript中，当你定义一个变量，这个变量的作用域要么是全局作用域（global scope），要么属于函数作用域。</p>
<blockquote>
<p>When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function. <small>—MDN</small></p>
</blockquote>
<p>JavaScript没有块级作用域，所以一个变量要么是全局变量（定义在任何函数之外），要么是局部变量（定义在函数内，属于该函数）。</p>
<p>全局变量的本质是全局对象（<em>global object</em>）的属性。在浏览器中，全局对象是<code>window</code>，所以全局变量可以通过<code>window.variable</code>来访问。</p>
<h2 id="Static/lexical_scope_vs_dynamic_scope">Static/lexical scope vs dynamic scope</h2><p>在了解完变量、值与作用域的知识后，我们正式来探索开头的那段代码。截取核心一段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'local'</span>;</span><br><span class="line">    printStr();  <span class="comment">// 当输出 "global" 时，代表这种语言是static scope，包括c/Java/JavaScript等等。</span></span><br><span class="line">    <span class="comment">// 当输出 "local" 时， 代表这种语言是 dynamic scope，如Perl等等。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>testScope</code>中输出”global”时，语言采用的是lexical scope;</li>
<li>当输出local”时则采用的是dynamic scope。</li>
</ul>
<p>关于scope的一个基本特征/最大区别就是<strong>part of a program（部分代码）</strong>到底指什么。</p>
<ul>
<li>当<em>part of a program</em>指代码块时，scope就是<em>static/lexical scope</em>;</li>
<li>而<em>part of a program</em>指程序运行时状态时，scope就是<em>dynamic scope</em>。</li>
</ul>
<p>所以说，区分<em>static/lexical scope</em>和<em>dynamic scope</em>的就是对<em>part of a program</em>的不同定义。</p>
<h3 id="Static/Lexical_Scope">Static/Lexical Scope</h3><p>对<em>lexical scope</em>而言，变量解析依赖于变量在源码中的位置，即文本上下文（lexical context）。lexical resolution可以在编译期间搞定——这也叫做<strong>early binding</strong>。</p>
<p>既然所有的变量都可以在编译期间解析出（all variable references can be resolved at compile-time），<em>lexical scope</em>有时也叫<em>static scope</em>。</p>
<p>// 通常来说，由于变量在编译期间都解析完毕，<em>lexical scope</em>有更好的性能。</p>
<p>Lexical scoping目前为止广泛运用于<code>ALGOL-influenced</code>语言，包括C/Java/JavaScript等等。</p>
<h3 id="Dynamic_Scope">Dynamic Scope</h3><p>对<em>dynamic scope</em>而言，解析变量名依赖于变量出现时程序的状态，即执行上下文或调用上下文（execution context or calling context）。dynamic resolution通常在运行时决定，也叫做<code>late binding</code>。</p>
<p>Lisp，Perl等使用Dynamic Scope。</p>
<h3 id="Lexical_scoping_vs_dynamic_scoping">Lexical scoping vs dynamic scoping</h3><p>使用局部变量（local variables，仅存在于特定函数内部）可以避免变量冲突。但怎么让变量仅存在于函数内部，有两种方式：</p>
<p>在<em>lexical scoping</em>（lexical scope，也称作static scoping或static scope）中，如果一个变量名（name）的作用域是一个特定的函数，那么它的作用域就是这个函数定义的代码块：在代码块内，变量名是存在的，变量名绑定到变量的值;在代码块外，变量名不存在。</p>
<p>相反，在<em>dynamic scoping</em>(dynamic scope)中，如果一个变量的作用域是一个特定函数，那么它的作用域就是这个函数执行的时间段：函数执行时，变量名存在且绑定到变量的值;但函数返回后（after the function returns），变量不再存在。</p>
<p><em>——-仍使用开头的代码说明——-</em></p>
<p>那么这意味着，函数<code>testScope</code>调用单独定义的<code>printStr</code>，</p>
<ul>
<li>在<em>lexical scoping</em>中，<code>printStr</code>无法访问<code>testScope</code>的局部变量（<code>printStr</code>不是在<code>testScope</code>内部定义的）。</li>
<li>在<em>dynamic scoping</em>中，<code>printStr</code>可以访问<code>testScope</code>的局部变量，因为<code>printStr</code>的调用是在<code>testScope</code>执行期间。</li>
</ul>
<h2 id="JavaScript的作用域体系">JavaScript的作用域体系</h2><p>前面提到JS是采用<em>lexical scoping</em>的，那么除了前面讲的关于<em>lexical scoping</em>的知识，还有什么要讲呢？</p>
<p>JS的scoping规则很简单，但是，变量初始化和名字解析可能会引发问题，而闭包的大量使用意味着函数定义时的词法环境（lexical environment）（用于变量名解析）和它执行时的词法环境（和变量名解析无关）可能有很大不同。另外，JS对象的属性名的名字解析又是另一个话题了（和变量、函数不同）。</p>
<h3 id="JavaScript的lexical_scoping">JavaScript的lexical scoping</h3><p>JS有函数级嵌套的<em>lexical scoping</em>，而global scope是最外层的scope。这个作用域体系（scoping）用于<strong>变量</strong>和<strong>函数（函数声明，与函数类型的变量相对）</strong>。</p>
<p>尽管JS的作用域体系很简单：就是lexical的，function-level的。相关的初始化和名字解析规则却可能引起困惑。</p>
<ol>
<li>没var时声明的变量是全局作用域的;</li>
<li>声明局部变量必须有var，变量提升（variable hoisting）;</li>
<li>在变量初始化之前访问是<code>undefined</code>，而不是语法错误;</li>
<li>函数声明的提升与变量提升不同;</li>
<li>闭包 。</li>
</ol>
<h3 id="JavaScript的闭包">JavaScript的闭包</h3><p>单独提一个小章节来讲闭包是必要的。闭包让JS无比强大，也是很多错误的来源。</p>
<p><strong>当一个函数执行时，名字解析依赖于它定义的位置（定义时的词法环境），而不是它执行时的词法环境。</strong>在JS中，特定函数（特别是闭包）的嵌套的作用域（从全局到最local的），有时也被称为作用域链，可以类比对象的原型链。</p>
<blockquote>
<p>The nested scopes of a particular function (from most global to most local) in JavaScript, particularly of a closure, used as a callback, are sometimes referred to as the scope chain, by analogy with the prototype chain of an object.</p>
</blockquote>
<p>闭包可以通过嵌套函数来产生。假设一个封闭函数，返回其内部嵌套的函数，包括封闭函数的局部变量作为这个被返回的函数的词法环境——这就是闭包。</p>
<p>闭包在JS中经常使用，但使用闭包是有风险的。</p>
<p>一个函数作为回调或者在另一个函数中返回，这样创建了闭包。如果这个函数的函数体中有变量没有绑定（带着它的作用域链），就会有风险。当基于参数创建回调，参数必须在闭包中存储，否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。</p>
<blockquote>
<p>When creating a callback based on parameters, the parameters must be stored in a closure, otherwise it will accidentally create a closure that refers to the variables in the enclosing environment, which may change.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i is '</span> + i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 10次 "i is 10"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i is '</span> + str);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line"><span class="comment">// i is 0</span></span><br><span class="line"><span class="comment">// i is 1</span></span><br><span class="line"><span class="comment">// i is 2</span></span><br><span class="line"><span class="comment">// i is 3</span></span><br><span class="line"><span class="comment">// i is 4</span></span><br><span class="line"><span class="comment">// i is 5</span></span><br><span class="line"><span class="comment">// i is 6</span></span><br><span class="line"><span class="comment">// i is 7</span></span><br><span class="line"><span class="comment">// i is 8</span></span><br><span class="line"><span class="comment">// i is 9</span></span><br></pre></td></tr></table></figure>
<hr>
<p>注意，本文的大部分术语/名词都尽量可靠翻译了:)，而且基本还带着英文原文。但有些名词翻译为中文仍可能引起歧义，下面列出了一些：</p>
<ul>
<li>name resolution：名字解析，变量名解析，变量的名字解析。对JS而言，包括变量、函数甚至对象等等的名字解析。</li>
<li>lexical environment：词法环境，指代码上下文/代码块。</li>
<li>scoping：作用域体系。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span ]]>
    </summary>
    
      <category term="dynamical scope， closure" scheme="http://creeperyang.github.io/tags/dynamical-scope%EF%BC%8C-closure/"/>
    
      <category term="lexical scope" scheme="http://creeperyang.github.io/tags/lexical-scope/"/>
    
      <category term="scope" scheme="http://creeperyang.github.io/tags/scope/"/>
    
      <category term="static scope" scheme="http://creeperyang.github.io/tags/static-scope/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/categories/frontend/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端模板分析（一）]]></title>
    <link href="http://creeperyang.github.io/2014/12/frontend-template-1/"/>
    <id>http://creeperyang.github.io/2014/12/frontend-template-1/</id>
    <published>2014-12-04T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>以一段简单的代码开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;<span class="comment">/*...*/</span>&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = data.list, <span class="comment">// will be like ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']</span></span><br><span class="line">        tmp = <span class="string">''</span>,</span><br><span class="line">        i, </span><br><span class="line">        len = list.length;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        tmp += <span class="string">'&lt;li&gt; index: '</span> + (i + <span class="number">1</span>) + <span class="string">', content: '</span> + list[i] + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">'#wrap'</span>).append(tmp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码就是实现<em>根据数据拼接字符串，修改文档DOM</em>的功能，很简单，大概每个前端程序员都写过，或至少感到熟悉。</p>
<!--view-break-->
<p>但当这种代码大片大片出现时，由于逻辑和视图杂糅，拼接字符串天然就让代码难以阅读和维护。如何避免写这种代码，或者说一种解决方案——模板，就是本章的核心。</p>
<p>从苦逼的拼接字符串，到因为<code>Backbone</code>认识<code>underscore template</code>，到学习<code>angular</code>而被双向绑定惊叹，再到了解<code>React</code>等新技术，我对模板的认识也在不断加深。而且近来因为工作原因，从<code>thinkphp模板</code>到<code>django模板</code>的各种后端模板，应该说也算熟练使用。</p>
<p>从这一章开始，我打算用2～3篇文章分析前端模板，本章作为第一篇，专注于字符串模板;之后的一两篇会讲以DOM为基础的模板和两者的混合版。</p>
<h3 id="字符串模板原理">字符串模板原理</h3><p>如果网上搜一搜，前端模板引擎真不少，尤其在node出现之后，不少js模板引擎更是横跨前后端。虽然每个引擎的语法、解析方式、字符串拼接的实现可能各有不同，但关键的渲染原理仍然是<strong>动态执行javascript字符串</strong>。</p>
<h4 id="模板使用和模板特征">模板使用和模板特征</h4><p>首先假设有这样一段模板使用示例（以underscore为例）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">'container'</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/template"</span> <span class="attribute">id</span>=<span class="value">"tpl"</span>&gt;</span><span class="vbscript-html"><span class="xml"></span><br><span class="line">    </span><span class="vbscript">&lt;% _.<span class="keyword">each</span>(games, <span class="keyword">function</span>(game) &#123; %&gt;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"item-vertical"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'/games/?uuid=</span></span></span><span class="vbscript">&lt;%= game.id %&gt;</span><span class="xml"><span class="tag"><span class="value">'</span>&gt;</span> </span><span class="vbscript">&lt;%- game.name %&gt;</span><span class="xml"> <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    </span><span class="vbscript">&lt;% &#125;);%&gt;</span><span class="xml"></span><br><span class="line"></span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="nimrod"></span><br><span class="line">    <span class="keyword">var</span> compiled = _.<span class="keyword">template</span>($('<span class="comment">#tpl').html());</span></span><br><span class="line">    $('<span class="comment">#container').html(compiled(data));</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出，相比原始的字符串拼接，模板在可读性、可维护性和易用性上有极大提升。</p>
<p>前端模板引擎的3个特征：</p>
<ol>
<li><p>前端模板一般有3种标签，分别是</p>
<ul>
<li>js代码执行标签（evaluate tag），标签内可以执行任意js代码，如<code>&lt;% _.each(games, function(game) { %&gt;</code>;</li>
<li>插值标签（interpolate tag），输出变量的对应值，如<code>&lt;%= game.id %&gt;</code>；</li>
<li>转义标签（escape tag），输出变量前先转义，如<code>&lt;%- game.name %&gt;</code>。注意：部分模板引擎可能省略这个标签。</li>
</ul>
</li>
<li><p>模板一般可以写在<code>script</code>标签里（即内联模板），但要注意改写type，可以是<code>text/template</code>及类似的（不写或写成<code>text/script</code>的话浏览器会当成脚本解析执行）。当然，用ajax加载等其它方法也可以，模板只是含有模板标签的字符串而已。</p>
</li>
<li><p>模板引擎的接口基本一致： <code>template(tpl, data, options)</code>。如果模板和数据都传入，返回渲染好的html字符串;如果只传了模板，则返回一个模板函数，该函数接收data返回字符串。</p>
</li>
</ol>
<h4 id="以unserscore模板为例分析模板实现">以unserscore模板为例分析模板实现</h4><p>废话不多说，以常用的unserscore内置模板讲解字符串模板的实现原理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3种标签，可配置更改</span></span><br><span class="line">_.templateSettings = &#123; <span class="comment">// 注意`？`——非贪婪匹配</span></span><br><span class="line">    evaluate: <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>,</span><br><span class="line">    interpolate: <span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>,</span><br><span class="line">    <span class="built_in">escape</span>: <span class="regexp">/&lt;%-([\s\S]+?)%&gt;/g</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> noMatch = <span class="regexp">/(.)^/</span>; <span class="comment">// 什么都不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要转义的字符，转义后才能放入字符串中</span></span><br><span class="line"><span class="keyword">var</span> escapes = &#123;</span><br><span class="line">    <span class="string">"'"</span>: <span class="string">"'"</span>,</span><br><span class="line">    <span class="string">'\\'</span>: <span class="string">'\\'</span>,</span><br><span class="line">    <span class="string">'\r'</span>: <span class="string">'r'</span>,</span><br><span class="line">    <span class="string">'\n'</span>: <span class="string">'n'</span>,</span><br><span class="line">    <span class="string">'\u2028'</span>: <span class="string">'u2028'</span>,</span><br><span class="line">    <span class="string">'\u2029'</span>: <span class="string">'u2029'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> escaper = <span class="regexp">/\\|'|\r|\n|\u2028|\u2029/g</span>;</span><br><span class="line"><span class="keyword">var</span> escapeChar = <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\\'</span> + escapes[match];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Underscore模板可以处理任意分隔符，保留空白，正确处理转义（在转义标签内）</span></span><br><span class="line">_.template = <span class="function"><span class="keyword">function</span>(<span class="params">text, settings, oldSettings</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// oldSettings只是为了兼容之前版本</span></span><br><span class="line">    <span class="keyword">if</span> (!settings &amp;&amp; oldSettings) settings = oldSettings;</span><br><span class="line">    settings = _.defaults(&#123;&#125;, settings, _.templateSettings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合分隔符为一个正则，分隔符是可选的</span></span><br><span class="line">    <span class="keyword">var</span> matcher = <span class="built_in">RegExp</span>([</span><br><span class="line">        (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source</span><br><span class="line">    ].join(<span class="string">'|'</span>) + <span class="string">'|$'</span>, <span class="string">'g'</span>); <span class="comment">// '|$'结束符在3种标签都不匹配时匹配，offset就是模板字符串长度，保证模板必然被转义处理（即source正确取到值）。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译模板字符串, 正确转义字符</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>; <span class="comment">// 配合offset来slice出3种标签之外的字符串</span></span><br><span class="line">    <span class="keyword">var</span> source = <span class="string">"__p+='"</span>;</span><br><span class="line">    text.replace(matcher, <span class="function"><span class="keyword">function</span>(<span class="params">match, escape, interpolate, evaluate, offset</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// offset是匹配到的子串的start index，所以下面一行是把匹配子串之前的子串转义并加入source</span></span><br><span class="line">        source += text.slice(index, offset).replace(escaper, escapeChar);</span><br><span class="line">        index = offset + match.length;</span><br><span class="line">        <span class="comment">// 3种标签内的内容不同处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123; <span class="comment">// 是转义，则把变量的值转义后加到source</span></span><br><span class="line">            source += <span class="string">"'+\n((__t=("</span> + <span class="built_in">escape</span> + <span class="string">"))==null?'':_.escape(__t))+\n'"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123; <span class="comment">// 插值，则把变量的值直接加到source</span></span><br><span class="line">            source += <span class="string">"'+\n((__t=("</span> + interpolate + <span class="string">"))==null?'':__t)+\n'"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123; <span class="comment">// 是js代码，则原样添加到source</span></span><br><span class="line">            source += <span class="string">"';\n"</span> + evaluate + <span class="string">"\n__p+='"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match;<span class="comment">// Adobe VMs必须返回match来正确生成offset</span></span><br><span class="line">    &#125;);</span><br><span class="line">    source += <span class="string">"';\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果settings.variable没有指定，那么用with来限制data到本地作用域</span></span><br><span class="line">    <span class="keyword">if</span> (!settings.variable) source = <span class="string">'with(obj||&#123;&#125;)&#123;\n'</span> + source + <span class="string">'&#125;\n'</span>;</span><br><span class="line">    <span class="comment">// 完整的source</span></span><br><span class="line">    <span class="comment">// print函数可以用来代替`=`： &lt;%= a %&gt; ==&gt; &lt;% print(a) %&gt;</span></span><br><span class="line">    source = <span class="string">"var __t,__p='',__j=Array.prototype.join,"</span> +</span><br><span class="line">        <span class="string">"print=function()&#123;__p+=__j.call(arguments,'');&#125;;\n"</span> +</span><br><span class="line">        source + <span class="string">'return __p;\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 构造编译函数，此处为模板引擎核心：</span></span><br><span class="line">        <span class="comment">// 通过构造Function来动态执行js字符串</span></span><br><span class="line">        <span class="keyword">var</span> render = <span class="keyword">new</span> <span class="built_in">Function</span>(settings.variable || <span class="string">'obj'</span>, <span class="string">'_'</span>, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        e.source = source;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> template = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 编译好的模板函数，调用只需传入数据即可</span></span><br><span class="line">        <span class="keyword">return</span> render.call(<span class="keyword">this</span>, data, _); <span class="comment">// 此处传入unserscore(_)作为参数，所以模板中可以使用unsercore的各种工具函数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把编译好的源码暴露到template.source，外部可以查看</span></span><br><span class="line">    <span class="keyword">var</span> argument = settings.variable || <span class="string">'obj'</span>;</span><br><span class="line">    template.source = <span class="string">'function('</span> + argument + <span class="string">')&#123;\n'</span> + source + <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> escapeMap = &#123;</span><br><span class="line">    <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,</span><br><span class="line">    <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,</span><br><span class="line">    <span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span>,</span><br><span class="line">    <span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>,</span><br><span class="line">    <span class="string">"'"</span>: <span class="string">'&amp;#x27;'</span>,</span><br><span class="line">    <span class="string">'`'</span>: <span class="string">'&amp;#x60;'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用来转义/逆转义</span></span><br><span class="line"><span class="keyword">var</span> createEscaper = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> escaper = <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map[match];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> source = <span class="string">'(?:'</span> + _.keys(map).join(<span class="string">'|'</span>) + <span class="string">')'</span>;</span><br><span class="line">    <span class="keyword">var</span> testRegexp = <span class="built_in">RegExp</span>(source);</span><br><span class="line">    <span class="keyword">var</span> replaceRegexp = <span class="built_in">RegExp</span>(source, <span class="string">'g'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">        string = string == <span class="literal">null</span> ? <span class="string">''</span> : <span class="string">''</span> + string;</span><br><span class="line">        <span class="keyword">return</span> testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">_.escape = createEscaper(escapeMap);</span><br></pre></td></tr></table></figure>
<p>以上是<a href="http://underscorejs.org/underscore.js" target="_blank" rel="external">underscore.js 1.7.0</a>的前端模板相关代码。</p>
<p>通过上面的源码以及注释可以看出，模板引擎实现很简单，就是分析处理模板，然后构造一个函数动态执行js字符串。下面罗列几个需要注意的点：</p>
<ul>
<li>模板分析的正则：（1）非贪婪匹配，（2）全局匹配<code>/g</code>，（3）组合正则时添加<code>|$</code>。结合这3点，replace时就可以正确处理模板。其中非贪婪匹配保证每个标签是逐一处理（匹配<code>&lt;%str%&gt;</code>而不是<code>&lt;%str%&gt;&lt;%str%&gt;</code>）;全局则是让匹配进行到底，处理完整个模板;<code>|$</code>保证模板一定被匹配，从而保证非标签内的字符串都被转义了。</li>
<li><code>with</code>的使用。<code>with</code>在JavaScript中算是臭名昭著，但前端模板应该是普遍使用了<code>with</code>，这里必然是有原因的。这里先不说，后面会专门一个小节来讲。</li>
</ul>
<h3 id="高效的字符串模板引擎">高效的字符串模板引擎</h3><p>知道了字符串模板引擎是怎么回事后，我们更近一步，来谈谈众多前端模板引擎的性能比较，并谈谈高效的原因。</p>
<p><em>注意：这里的模板引擎仅仅指基于字符串的模板引擎，像angular之类的并不包括在内。公平而言，基于DOM的模板引擎（angular等）编译模板时会进行双向绑定，干的事远比字符串模板更多、更复杂，与字符串模板放在一起比较不合适。</em></p>
<p>参考<code>artTemplate</code>项目的测试<a href="http://aui.github.io/artTemplate/test/test-speed.html" target="_blank" rel="external">http://aui.github.io/artTemplate/test/test-speed.html</a></p>
<p><img src="http://creeper-static.qiniudn.com/stc-tpl-speed-test.png" alt="speed-test"></p>
<p>从图中可以看出，<code>artTemplate</code>的速度在主流的几款前端模板中，速度突出。那么，比较上面分析的<code>unsercore template</code>来看看<code>artTemplate</code>做了哪些特殊处理/优化。</p>
<h4 id="artTemplate模板引擎实现分析">artTemplate模板引擎实现分析</h4><p>去除一些细枝末节，直接分析artTemplate的核心实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compiler</span>(<span class="params">source, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> debug = options.debug;</span><br><span class="line">    <span class="keyword">var</span> openTag = options.openTag;</span><br><span class="line">    <span class="keyword">var</span> closeTag = options.closeTag;</span><br><span class="line">    <span class="keyword">var</span> parser = options.parser;</span><br><span class="line">    <span class="keyword">var</span> compress = options.compress;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">escape</span> = options.escape; <span class="comment">// 以上为配置项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line = <span class="number">1</span>; <span class="comment">// 记录行号</span></span><br><span class="line">    <span class="keyword">var</span> uniq = &#123; <span class="comment">// flag，用来标志该变量是否在函数（最终构造的模板函数）顶部已声明</span></span><br><span class="line">        $data: <span class="number">1</span>,</span><br><span class="line">        $filename: <span class="number">1</span>,</span><br><span class="line">        $utils: <span class="number">1</span>,</span><br><span class="line">        $helpers: <span class="number">1</span>,</span><br><span class="line">        $out: <span class="number">1</span>,</span><br><span class="line">        $line: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过是否有 ''.trim 方法来判断ie6-8还是现代浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isNewEngine = <span class="string">''</span>.trim; <span class="comment">// '__proto__' in &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按是否是现代浏览器准备了2套处理方式</span></span><br><span class="line">    <span class="keyword">var</span> replaces = isNewEngine</span><br><span class="line">    ? [<span class="string">"$out='';"</span>, <span class="string">"$out+="</span>, <span class="string">";"</span>, <span class="string">"$out"</span>]</span><br><span class="line">    : [<span class="string">"$out=[];"</span>, <span class="string">"$out.push("</span>, <span class="string">");"</span>, <span class="string">"$out.join('')"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> concat = isNewEngine</span><br><span class="line">        ? <span class="string">"$out+=text;return $out;"</span></span><br><span class="line">        : <span class="string">"$out.push(text);"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 工具函数：print函数、include函数</span></span><br><span class="line">    <span class="keyword">var</span> print = <span class="string">"function()&#123;"</span></span><br><span class="line">    +      <span class="string">"var text=''.concat.apply('',arguments);"</span></span><br><span class="line">    +       concat</span><br><span class="line">    +  <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> include = <span class="string">"function(filename,data)&#123;"</span></span><br><span class="line">    +      <span class="string">"data=data||$data;"</span></span><br><span class="line">    +      <span class="string">"var text=$utils.$include(filename,data,$filename);"</span></span><br><span class="line">    +       concat</span><br><span class="line">    +   <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备工作：初始化headerCode、mainCode、footerCode</span></span><br><span class="line">    <span class="keyword">var</span> headerCode = <span class="string">"'use strict';"</span></span><br><span class="line">    + <span class="string">"var $utils=this,$helpers=$utils.$helpers,"</span></span><br><span class="line">    + (debug ? <span class="string">"$line=0,"</span> : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">var</span> mainCode = replaces[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> footerCode = <span class="string">"return new String("</span> + replaces[<span class="number">3</span>] + <span class="string">");"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：html与逻辑语法分别处理</span></span><br><span class="line">    <span class="comment">// 首先通过openTag split成数组A; A中的元素要么是纯html字符串，要么含有closeTag</span></span><br><span class="line">    forEach(source.split(openTag), <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">        code = code.split(closeTag); <span class="comment">// 尝试用closeTag切分A中的每个元素</span></span><br><span class="line">        <span class="keyword">var</span> $<span class="number">0</span> = code[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> $<span class="number">1</span> = code[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (code.length === <span class="number">1</span>) &#123; <span class="comment">// 说明该code是纯html字符串，$1为空</span></span><br><span class="line">            mainCode += html($<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时$0是标签之间的逻辑代码，$1是纯html字符串</span></span><br><span class="line">            mainCode += logic($<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ($<span class="number">1</span>) &#123;</span><br><span class="line">                mainCode += html($<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 模板分析处理完毕，组合成new Function所需的source</span></span><br><span class="line">    <span class="keyword">var</span> code = headerCode + mainCode + footerCode;</span><br><span class="line">    <span class="comment">// 调试语句</span></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        code = <span class="string">"try&#123;"</span> + code + <span class="string">"&#125;catch(e)&#123;"</span> + <span class="string">"throw &#123;"</span> + <span class="string">"filename:$filename,"</span> + <span class="string">"name:'Render Error',"</span> + <span class="string">"message:e.message,"</span> + <span class="string">"line:$line,"</span> + <span class="string">"source:"</span> + stringify(source) + <span class="string">".split(/\\n/)[$line-1].replace(/^\\s+/,'')"</span> + <span class="string">"&#125;;"</span> + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 新建函数，source就是code。</span></span><br><span class="line">        <span class="keyword">var</span> Render = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"$data"</span>, <span class="string">"$filename"</span>, code);</span><br><span class="line">        Render.prototype = utils; <span class="comment">// 这个很有意思，通过原型（因为utils = template.utils），让函数内部（也就是模板中）可以使用模板自带的/自己扩展的各种工具函数</span></span><br><span class="line">        <span class="keyword">return</span> Render;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        e.temp = <span class="string">"function anonymous($data,$filename) &#123;"</span> + code + <span class="string">"&#125;"</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 HTML 语句</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">html</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">        line += code.split(<span class="regexp">/\n/</span>).length - <span class="number">1</span>; <span class="comment">// 记录行号</span></span><br><span class="line">        <span class="keyword">if</span> (compress) &#123; <span class="comment">// 压缩多余空白与注释</span></span><br><span class="line">            code = code.replace(<span class="regexp">/\s+/g</span>, <span class="string">' '</span>).replace(<span class="regexp">/&lt;!--[\w\W]*?--&gt;/g</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (code) &#123; <span class="comment">// `$out+=`+转义后的code+`;` 或者 `$out.push(`+转义后的code+`);`</span></span><br><span class="line">            code = replaces[<span class="number">1</span>] + stringify(code) + replaces[<span class="number">2</span>] + <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理逻辑语句</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">logic</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> thisLine = line;</span><br><span class="line">        <span class="keyword">if</span> (parser) &#123; <span class="comment">// 逻辑语句的钩子</span></span><br><span class="line">            code = parser(code, options);<span class="comment">// artTemplate的语法转换插件钩子，如果原生语法用不到，当然，也可以自己挂进来另一套语法处理规则。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (debug) &#123; <span class="comment">// debug时处理行号</span></span><br><span class="line">            code = code.replace(<span class="regexp">/\n/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 记录行号</span></span><br><span class="line">                line++;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"$line="</span> + line + <span class="string">";"</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出语句. 编码: &lt;%=value%&gt; 不编码:&lt;%=#value%&gt;</span></span><br><span class="line">        <span class="comment">// &lt;%=#value%&gt; 等同 v2.0.3 之前的 &lt;%==value%&gt;</span></span><br><span class="line">        <span class="comment">// 此时的code已去除openTag(&lt;%)和closeTag(%&gt;)</span></span><br><span class="line">        <span class="keyword">if</span> (code.indexOf(<span class="string">'='</span>) === <span class="number">0</span>) &#123; <span class="comment">// 验证是模板标签</span></span><br><span class="line">            <span class="keyword">var</span> escapeSyntax = <span class="built_in">escape</span> &amp;&amp; !<span class="regexp">/^=[=#]/</span>.test(code); <span class="comment">// escape为true，且标签不是 `&lt;%=#value%&gt;&lt;%==value%&gt;`（不编码直接输出） 标签</span></span><br><span class="line">            code = code.replace(<span class="regexp">/^=[=#]?|[\s;]*$/g</span>, <span class="string">''</span>); <span class="comment">// 去除残余标签（=，==，=#之类）</span></span><br><span class="line">            <span class="keyword">if</span> (escapeSyntax) &#123; <span class="comment">// 需要对内容编码</span></span><br><span class="line">                <span class="comment">// /\s*\([^\)]+\)/ ===&gt; 是否是`（something）`这种形式</span></span><br><span class="line">                <span class="comment">// 即删除括号及里面内容，例如`include('/tpl.html')`==&gt;`include`</span></span><br><span class="line">                <span class="keyword">var</span> name = code.replace(<span class="regexp">/\s*\([^\)]+\)/</span>, <span class="string">''</span>);</span><br><span class="line">                <span class="comment">// 排除 utils.* | include | print</span></span><br><span class="line">                <span class="keyword">if</span> (!utils[name] &amp;&amp; !<span class="regexp">/^(include|print)$/</span>.test(name)) &#123;</span><br><span class="line">                    code = <span class="string">"$escape("</span> + code + <span class="string">")"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不编码</span></span><br><span class="line">                code = <span class="string">"$string("</span> + code + <span class="string">")"</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// code = `$out+=`+`$escape/string( + code + )`+`;`</span></span><br><span class="line">            code = replaces[<span class="number">1</span>] + code + replaces[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            code = <span class="string">"$line="</span> + thisLine + <span class="string">";"</span> + code;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提取模板中的变量名，然后（1）除print/include外，为变量名添加`$data`等前缀（2）把变量声明加到headerCode</span></span><br><span class="line">        forEach(getVariable(code), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// name 值可能为空，在安卓低版本浏览器下</span></span><br><span class="line">            <span class="keyword">if</span> (!name || uniq[name]) &#123; <span class="comment">// 该name已经在变量声明中声明，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> value; <span class="comment">// 声明模板变量</span></span><br><span class="line">            <span class="comment">// 赋值优先级: [include, print] &gt; utils &gt; helpers &gt; data</span></span><br><span class="line">            <span class="keyword">if</span> (name === <span class="string">'print'</span>) &#123;</span><br><span class="line">                value = print;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'include'</span>) &#123;</span><br><span class="line">                value = include;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (utils[name]) &#123; <span class="comment">// $escape, $string在这一步处理</span></span><br><span class="line">                value = <span class="string">"$utils."</span> + name;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (helpers[name]) &#123;</span><br><span class="line">                value = <span class="string">"$helpers."</span> + name;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = <span class="string">"$data."</span> + name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在开头中添加变量声明</span></span><br><span class="line">            headerCode += name + <span class="string">"="</span> + value + <span class="string">","</span>;</span><br><span class="line">            uniq[name] = <span class="literal">true</span>; <span class="comment">// flag设为true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 可以看到，artTemplate只对输出标签做了处理，js代码标签原样输出</span></span><br><span class="line">        <span class="keyword">return</span> code + <span class="string">"\n"</span>; <span class="comment">// 返回code，code加换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>artTemplate的工具函数分析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转义 ---&gt; 处理html时使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"'"</span> + code</span><br><span class="line">    .replace(<span class="regexp">/('|\\)/g</span>, <span class="string">'\\$1'</span>) <span class="comment">// 单引号与反斜杠转义</span></span><br><span class="line">    .replace(<span class="regexp">/\r/g</span>, <span class="string">'\\r'</span>) <span class="comment">// 换行符转义(windows + linux)</span></span><br><span class="line">    .replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>) + <span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内置的一些工具函数，可以扩展</span></span><br><span class="line"><span class="keyword">var</span> utils = template.utils = &#123;</span><br><span class="line">    $helpers: &#123;&#125;,</span><br><span class="line">    $include: renderFile,</span><br><span class="line">    $string: toString,</span><br><span class="line">    $<span class="built_in">escape</span>: escapeHTML,</span><br><span class="line">    $each: each</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> toString = <span class="function"><span class="keyword">function</span> (<span class="params">value, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'string'</span>) &#123; <span class="comment">// 如果不是字符串</span></span><br><span class="line">        type = <span class="keyword">typeof</span> value;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'number'</span>) &#123; <span class="comment">// 数字则转字符串</span></span><br><span class="line">            value += <span class="string">''</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'function'</span>) &#123; <span class="comment">// 是函数则取执行结果</span></span><br><span class="line">            value = toString(value.call(value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其它返回空字符串</span></span><br><span class="line">            value = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> escapeMap = &#123;</span><br><span class="line">    <span class="string">"&lt;"</span>: <span class="string">"&amp;#60;"</span>,</span><br><span class="line">    <span class="string">"&gt;"</span>: <span class="string">"&amp;#62;"</span>,</span><br><span class="line">    <span class="string">'"'</span>: <span class="string">"&amp;#34;"</span>,</span><br><span class="line">    <span class="string">"'"</span>: <span class="string">"&amp;#39;"</span>,</span><br><span class="line">    <span class="string">"&amp;"</span>: <span class="string">"&amp;#38;"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义escapeMap中的五个字符为html实体</span></span><br><span class="line"><span class="keyword">var</span> escapeFn = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> escapeMap[s];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /&amp;(?![\w#]+;)/g  当且仅当 是`&amp;`且`&amp;`后面不是`[\w#]+;`</span></span><br><span class="line"><span class="comment">// /[&lt;&gt;"']/g 有`&lt;&gt;"'`4字符中任意一个</span></span><br><span class="line"><span class="comment">// 函数功能：转义`&lt;&gt;"'`以及`&amp;`（`&amp;`后面不是`[\w#]+;`——即已经转义）</span></span><br><span class="line"><span class="keyword">var</span> escapeHTML = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString(content)</span><br><span class="line">    .replace(<span class="regexp">/&amp;(?![\w#]+;)|[&lt;&gt;"']/g</span>, escapeFn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&#123;&#125;).toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历对象或数组</span></span><br><span class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, len;        </span><br><span class="line">    <span class="keyword">if</span> (isArray(data)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">            callback.call(data, data[i], i, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> data) &#123;</span><br><span class="line">            callback.call(data, data[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>artTemplate的变量提取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态分析模板变量</span></span><br><span class="line"><span class="keyword">var</span> KEYWORDS =</span><br><span class="line">    <span class="comment">// 关键字</span></span><br><span class="line">    <span class="string">'break,case,catch,continue,debugger,default,delete,do,else,false'</span></span><br><span class="line">    + <span class="string">',finally,for,function,if,in,instanceof,new,null,return,switch,this'</span></span><br><span class="line">    + <span class="string">',throw,true,try,typeof,var,void,while,with'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留字</span></span><br><span class="line">    + <span class="string">',abstract,boolean,byte,char,class,const,double,enum,export,extends'</span></span><br><span class="line">    + <span class="string">',final,float,goto,implements,import,int,interface,long,native'</span></span><br><span class="line">    + <span class="string">',package,private,protected,public,short,static,super,synchronized'</span></span><br><span class="line">    + <span class="string">',throws,transient,volatile'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ECMA 5 - use strict</span></span><br><span class="line">    + <span class="string">',arguments,let,yield'</span></span><br><span class="line"></span><br><span class="line">    + <span class="string">',undefined'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// REMOVE_RE匹配注释（//  /**/）以及字符串（`"string"` `'string'`）</span></span><br><span class="line"><span class="keyword">var</span> REMOVE_RE = <span class="regexp">/\/\*[\w\W]*?\*\/|\/\/[^\n]*\n|\/\/[^\n]*$|"(?:[^"\\]|\\[\w\W])*"|'(?:[^'\\]|\\[\w\W])*'|\s*\.\s*[$\w\.]+/g</span>;</span><br><span class="line"><span class="comment">// 匹配[A-Za-z0-9_$]之外的</span></span><br><span class="line"><span class="keyword">var</span> SPLIT_RE = <span class="regexp">/[^\w$]+/g</span>;</span><br><span class="line"><span class="comment">// 匹配关键字 `\bkeyword\b` 匹配 `var str='str'`中的`var`</span></span><br><span class="line"><span class="keyword">var</span> KEYWORDS_RE = <span class="keyword">new</span> <span class="built_in">RegExp</span>([<span class="string">"\\b"</span> + KEYWORDS.replace(<span class="regexp">/,/g</span>, <span class="string">'\\b|\\b'</span>) + <span class="string">"\\b"</span>].join(<span class="string">'|'</span>), <span class="string">'g'</span>);</span><br><span class="line"><span class="comment">// 匹配以数字(或,数字)开头的字符串(`200s` ',200s')</span></span><br><span class="line"><span class="keyword">var</span> NUMBER_RE = <span class="regexp">/^\d[^,]*|,\d[^,]*/g</span>;</span><br><span class="line"><span class="comment">// 开头或结尾的逗号</span></span><br><span class="line"><span class="keyword">var</span> BOUNDARY_RE = <span class="regexp">/^,+|,+$/g</span>;</span><br><span class="line"><span class="keyword">var</span> SPLIT2_RE = <span class="regexp">/^$|,+/</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVariable</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">    .replace(REMOVE_RE, <span class="string">''</span>) <span class="comment">// 删除注释和字符串</span></span><br><span class="line">    .replace(SPLIT_RE, <span class="string">','</span>) <span class="comment">// js代码把[空格 ; ,]等待替换成`,`，即把合法的js代码切分</span></span><br><span class="line">    .replace(KEYWORDS_RE, <span class="string">''</span>) <span class="comment">// 删除所有的关键字</span></span><br><span class="line">    .replace(NUMBER_RE, <span class="string">''</span>) <span class="comment">// 删除以数字开头的字符串（显然不是合法的变量名）</span></span><br><span class="line">    .replace(BOUNDARY_RE, <span class="string">''</span>) <span class="comment">// 删除开头或结尾的逗号</span></span><br><span class="line">    .split(SPLIT2_RE); <span class="comment">// 以逗号分割</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    getVariable('var m = list;'); // ["m", "list"]</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>至此，<code>artTemplate</code>的（核心）源码分析完毕，原理与<code>underscore</code>模板基本一致。</p>
<p><code>underscore</code>模板处理逻辑很简单，基本就是：html转义后输出;插值和js代码原样输出。处理逻辑中只有一个简单的<code>null/undefined</code>不输出。</p>
<p><code>artTemplate</code>模板处理更为复杂：</p>
<ol>
<li>html字符串根据设置来原样或转义输出;</li>
<li>逻辑字符串通用根据设置来原样或转义输出，但逻辑字符串中需要提取变量加到头部。</li>
</ol>
<p><code>artTemplate</code>相比<code>underscore template</code>在逻辑字符串上处理的不同也正是性能差异的关键：</p>
<ol>
<li><code>underscore template</code>几乎原样输出，这种简单处理导致了<code>with</code>的引进，或者说基于<code>with</code>才可以这样简单处理;</li>
<li><code>artTemplate</code>在逻辑字符串（js代码）中提取变量然后在顶部声明，弃用<code>with</code>。</li>
</ol>
<h4 id="artTemplate模板引擎高效原因1——with">artTemplate模板引擎高效原因1——with</h4><p>正如上面所说，抛弃<code>with</code>是artTemplate高效的最大原因。那么<code>with</code>为什么对性能影响如此之大？</p>
<p>首先确认<code>with</code>的确会显著降低js性能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funWith = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(data) &#123;</span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funNoWith = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data.index = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExecuteTime</span>(<span class="params">fun, args, times</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">        start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; times; i++) &#123;</span><br><span class="line">        fun(args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeWith = getExecuteTime(funWith, &#123;index: <span class="number">0</span>&#125;, <span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">var</span> timeNoWith = getExecuteTime(funNoWith, &#123;index: <span class="number">0</span>&#125;, <span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'timeWith'</span>, timeWith, <span class="string">' timeNoWith'</span>, timeNoWith);</span><br></pre></td></tr></table></figure>
<p><img src="http://creeper-static.qiniudn.com/stc-with-test.png" alt="测试结果"></p>
<p>如上可以看出，<code>with</code>对性能的影响巨大。</p>
<p><code>with</code>影响性能的两个原因：</p>
<h5 id="1-_影响作用域链">1. 影响作用域链</h5><p>在一个给定的执行环境中作用域链通常是不变的，但有两种情况会暂时增强作用域链（增加一级）。两种情形一个是<code>try catch</code>，另一个就是<code>with</code>。</p>
<p><code>with</code>会在当前作用域链的最底层添加一个对象（即变成作用域链上第一个对象），这个对象的所有属性都可以直接访问而不必通过<code>.</code>操作符访问，这显然很方便。但作用域链上多出的这个对象会影响（hurt）本地变量解析，因为一旦<code>with</code>语句执行，本地变量将位于<a href="http://archive.oreilly.com/pub/a/server-administration/excerpts/even-faster-websites/writing-efficient-javascript.html#scope_chain_augmentation_using_the_with_" target="_blank" rel="external">作用域链</a>上的第二个对象。</p>
<h5 id="2-_with阻止js引擎的优化编译器的优化">2. <code>with</code>阻止js引擎的优化编译器的优化</h5><p><a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">V8引擎</a>有两个不同的编译器：通用编译器（generic）和优化编译器（optimizing）。这意味着你的js代码被编译并直接以原生代码执行。那么，这是不是说你的代码会非常快？</p>
<p>错了，（js）代码被编译为原生代码本身并不意味着性能大大提升，编译只是消除了解释器开销，如果没有优化的话，（原生）代码可能仍然很慢。注意，这里的编译指通过通用编译器编译。</p>
<p>例如：js代码<code>a + b</code>通过通用编译器编译后可能是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">call RuntimeAdd</span><br></pre></td></tr></table></figure>
<p>也就是说，它只是调用了运行时的函数。如果<code>a</code>和<code>b</code>是整数的话，可能是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, a</span><br><span class="line">mov ebx, b</span><br><span class="line">add eax, ebx</span><br></pre></td></tr></table></figure>
<p>显然，这会极大地提高性能。通常情况下，通用编译器编译出来的就是前一种代码，而优化编译器编译出来的就是后一种代码。优化编译器编译后通常会有<code>100X</code>的性能提升。</p>
<p>那么具体到我们的<code>with</code>，<code>with</code>语句所在的函数不会被优化编译器优化。这是因为<code>with</code>块内是<code>dynamical scoped</code>，不是通常的<code>Lexical scoped</code>，这导致无法在编译时决定是绑定到哪个变量的（只能在运行时动态检测）。</p>
<p>所以，<code>with</code>非常影响性能。</p>
<h4 id="artTemplate模板引擎高效原因2——字符串相加">artTemplate模板引擎高效原因2——字符串相加</h4><p>可以看到artTemplate中有<code>array.push</code>和一般的<code>+=</code>两种字符串相加方式。</p>
<p>很多人误以为数组 push 方法拼接字符串会比 += 快，但这仅仅是 IE6-8 的浏览器下。实测表明现代浏览器使用 += 会比数组 push 方法快，而在 v8 引擎中，使用 += 方式比数组拼接快 4.7 倍。所以 artTemplate 根据 javascript 引擎特性采用了两种不同的字符串拼接方式。</p>
<h3 id="结束语">结束语</h3><p>本篇博文中，我分析了<code>underscore template</code>和<code>artTemplate</code>两个模板引擎，借助这两个模板引擎，基于字符串的模板引擎的特征和原理应该清楚了。</p>
<p>我们可以看到<code>artTemplate</code>对于<code>underscore template</code>在性能上的优化，但模板非常耗费时间的一点——<code>dom.innerHTML = compiledString</code>，基于字符串的模板引擎都没有涉及到（也无法涉及，因为基于字符串的模板从始至终都只是字符串的处理）。</p>
<p>另外，当数据变化时，字符串模板引擎只是不断的重复<code>dom.innerHTML = compiledString</code>，而这里有很大的性能浪费，毕竟大部分情况不需要替换所有dom元素，可能只需要更新文本而已。而一旦替换全部dom元素，那么事件等等也都需要重新绑定。</p>
<p>为了解决这些问题，第二代模板——基于dom的模板如angularjs、avalonjs等等出现了，前端模板系列的下一篇的重点就将关注它们的实现原理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以一段简单的代码开始：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line"]]>
    </summary>
    
      <category term="string-based template" scheme="http://creeperyang.github.io/tags/string-based-template/"/>
    
      <category term="template" scheme="http://creeperyang.github.io/tags/template/"/>
    
      <category term="模板" scheme="http://creeperyang.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript基础——变量、作用域、命名空间和预编译]]></title>
    <link href="http://creeperyang.github.io/2014/11/javascript-base-about-scoping-and-precompile/"/>
    <id>http://creeperyang.github.io/2014/11/javascript-base-about-scoping-and-precompile/</id>
    <published>2014-11-27T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>什么是命名空间，变量污染，变量声明提升，预编译？如何检查一段代码执行后是否声明了全局变量？</p>
<p>这些问题聚焦于一个核心：变量与作用域，而这恰恰是JavaScript作为一门语言没有处理好的地方，所以有很多疑问都很正常。</p>
<!--view-break-->
<p>这篇文章其实是前面文章<a href="/frontend/2014/11/javascript-scoping-and-hoisting/">JavaScript Scoping and Hoisting</a>的后续，如果能阅读前一篇之后再来看这篇，可能会更好，因为许多关于变量提升的解释都在里面。</p>
<p>进入正文，列下几点分别解释：</p>
<h2 id="1-_变量与作用域">1. 变量与作用域</h2><p>JavaScript是一门弱类型语言，这意味着你<em>不需要提前声明变量的类型</em>，变量的类型是程序执行时由引擎自动确定的。这既是JavaScript的强大之处，也是许多bug出现或代码质量差的一个原因。</p>
<h3 id="变量与变量声明">变量与变量声明</h3><p>JS的数据类型有7种，其中基本类型6种，分别是<code>Boolean</code>,<code>NUll</code>,<code>Undefined</code>,<code>Number</code>,<code>String</code>,<code>Symbol</code>（ECMAScript6新提出）;然后对象<code>Object</code>一种。</p>
<p>在JS中，我们通过<code>var</code>关键字即可声明一个局部变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;    <span class="comment">// foo is a Number now</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">"bar"</span>; <span class="comment">// foo is a String now</span></span><br></pre></td></tr></table></figure>
<p>变量声明是如此简单，但请<strong>注意</strong>，变量声明中一旦缺失<code>var</code>关键字，那么声明的变量就是全局变量！</p>
<p>这样相当危险，因为你不知道这个变量会不会覆盖/污染某个全局变量，比如在一个基于<code>jQuery</code>的页面中写一句<code>$ = &#39;whatever&#39;;</code>很可能造成程序崩溃。过多的全局变量会加大引起冲突的可能。</p>
<h3 id="作用域">作用域</h3><p>与变量密切相关的一个概念就是作用域。JS的作用域容易困惑的一点就是：JS本身是类C语言，但它的作用域体系与C完全不同。</p>
<p>在C中，一个<code>if</code>语句块可以有自己的作用域，但在JS中，没有块级作用域，JS中<strong>唯一能创建新的作用域的只有函数</strong>。所以JS中只有<strong>全局作用域</strong>和<strong>函数级作用域</strong>。而基于这一点，匿名自执行函数就成了绝大多数JS类库创建自己作用域的唯一选择。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名自执行函数</span></span><br><span class="line">; (<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建new scope, 不会污染全局作用域</span></span><br><span class="line">&#125;)(args);</span><br></pre></td></tr></table></figure>
<p>以上写法是包括<code>jQuery</code>在内的很多类库采用的。</p>
<h2 id="2-_命名空间">2. 命名空间</h2><p>JS是没有命名空间这个概念的，所以只能模拟。至于为什么需要命名空间，很简单，命名空间可以显著减少命名冲突，并很好的组织代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace = namespace || &#123;&#125;;</span><br><span class="line">namespace.AModule = &#123;&#125;;</span><br><span class="line">namespace.AModule.name = <span class="string">"Kate"</span>;</span><br><span class="line">namespace.BModule = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面是一段简单的命名空间模拟，更具体深入的阐述可以参考<a href="http://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/" target="_blank" rel="external">http://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/</a>。</p>
<h2 id="3-_预编译">3. 预编译</h2><p>JavaScript预编译听起来高大上，但其实还是比较简单的。</p>
<p>首先，对一段JS代码，JS引擎并不是读一句执行一句，而是读取一段、解释执行一段。而一段一段执行，JS会对读取的这段JS代码整体有个预处理，这个预处理就是所谓的预编译。</p>
<p>预编译阶段，JS引擎会进行变量提升，详细可看<a href="/frontend/2014/11/javascript-scoping-and-hoisting/">JavaScript Scoping and Hoisting</a>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="actionscript"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jerry'</span>;</span><br><span class="line">sayHi(name);  <span class="comment">// 输出 'Hi Jerry!'</span></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(name);  <span class="comment">// 输出 'Hello Jerry!'</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上，因为JS的预编译，所以执行第一个<code>sayHi(name);</code>可以正常输出<code>Hi Jerry!</code>而不是<code>sayHi</code>未定义。而第二个<code>sayHi(name);</code> 执行时函数<code>sayHi</code>也被重新赋值，会输出<code>Hello Jerry!</code>。</p>
<p>再看下面一段代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="actionscript"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jerry'</span>;</span><br><span class="line">sayHi(name);  <span class="comment">// 输出 'Hi Jerry!'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="actionscript"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jerry'</span>;</span><br><span class="line">sayHi(name);  <span class="comment">// 输出 'Hello Jerry!'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为JS的预编译，两个<code>script</code>标签分成2段代码分别读取解释执行，所以两个<code>script</code>标签内我们都可以得到预期的输出，而不是第二个<code>sayHi</code>覆盖了第一个<code>sayHi</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>什么是命名空间，变量污染，变量声明提升，预编译？如何检查一段代码执行后是否声明了全局变量？</p>
<p>这些问题聚焦于一个核心：变量与作用域，而这恰恰是JavaScript作为一门语言没有处理好的地方，所以有很多疑问都很正常。</p>
<!--view-break-->
]]>
    </summary>
    
      <category term="hoisting" scheme="http://creeperyang.github.io/tags/hoisting/"/>
    
      <category term="scoping" scheme="http://creeperyang.github.io/tags/scoping/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Scoping and Hoisting]]></title>
    <link href="http://creeperyang.github.io/2014/11/javascript-scoping-and-hoisting/"/>
    <id>http://creeperyang.github.io/2014/11/javascript-scoping-and-hoisting/</id>
    <published>2014-11-05T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>这篇是<a href="/frontend/2014/10/javascript-hoisting/">「JavaScript Hoisting」</a>的进阶篇，参照了大牛<strong>Ben</strong>的<a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="external">「JavaScript Scoping and Hoisting」</a>。</p>
<p>首先介绍一下<strong>Ben</strong>：</p>
<blockquote>
<p>Ben is a 25 year-old software engineer. He lives and works in San Francisco. Many people think he invented the term “hoisting” in JavaScript, but this is untrue.</p>
</blockquote>
<!--view-break-->
<p>但不管是不是Ben发明了”JavaScript Hoisting”，他关于Hoisting的阐释是透彻和深刻的。本文大部分内容是对它文章的翻译，英文好的同学可以直接阅读<a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="external">原文</a>。英文吃力的或者嫌麻烦的可以接着看。</p>
<h2 id="让你大吃一惊的例子">让你大吃一惊的例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1:</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2:</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>
<p>不妨先想想浏览器会输出什么，然后运行代码对照，那么结果会让大部分人大吃一惊，大部分人都会感到困惑不解。（上面的例子中，例1会输出<code>10</code>，例2会输出<code>1</code>。）</p>
<p>那么为什么会有这样的结果？这就是这篇文章要说的「JavaScript Hoisting」，但要理解这个概念必须先从scope说起。</p>
<h2 id="Scoping_in_JavaScript">Scoping in JavaScript</h2><p>js新手（可能不止新手）的一个困扰源就是作用域。js作用域为什么让人困惑的原因是js是一门类似C的语言，但它的作用域体系又和C不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, "</span>, x); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>, x); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一段C代码，C有块级作用域（<code>block-level scope</code>），所以进入if语句块后，新的变量可以定义在块内而不影响外部变量。但JS不一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>JS没有块级作用域！所以if内的<code>x</code>覆盖了外部的<code>x</code>。</p>
<p>但JS有函数级作用域（<code>function-level scope</code>）。例如if语句之类的不会创建新的作用域，在JS中只有函数会创建新的作用域。</p>
<h2 id="Declarations,_Names,_and_Hoisting">Declarations, Names, and Hoisting</h2><p>在js中，一个变量名进入作用域的方式有4种：</p>
<ol>
<li>Language-defined：所有的作用域默认都会给出<code>this</code>和<code>arguments</code>两个变量名;</li>
<li>Formal parameters（形参）：函数有形参，形参会添加到函数的作用域中;</li>
<li>Function declarations（函数声明）：如<code>function foo() {}</code>;</li>
<li>Variable declarations（变量声明）：如<code>var foo</code>。</li>
</ol>
<p>函数声明和变量声明总是会被编译器移动（即hoist）到它们所在的作用域的顶部（这对你是透明的）。至于<code>Language-defined</code>和形参，显然，它们已经在顶部了。</p>
<p>注意，提升的只有变量声明，变量初始化是不会提升的。更具体的情况可以看前一篇<a href="/frontend/2014/10/javascript-hoisting/">「JavaScript Hoisting」</a>。</p>
<h3 id="Name_Resolution_Order">Name Resolution Order</h3><p>最重要的特殊情况是变量解析顺序。这个顺序与前面提到的变量进入作用域的4种方式的顺序一致。</p>
<p>这说明，如果一个变量名已经被定义了，它就再也不会被重新声明。这也意味着，函数声明的优先级要高于变量声明。</p>
<p>当然，这不是说赋值无效了，而是变量声明部分被解释器忽略了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testOrder</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// arg是形参，不会被重新定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 因为函数声明比变量声明优先级高，所以这里a是函数</span></span><br><span class="line">    <span class="keyword">var</span> arg = <span class="string">'hello'</span>; <span class="comment">// var arg;变量声明被忽略， arg = 'hello'被执行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// var a;被忽视; a = 10被执行，a变成number</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fun'</span>);</span><br><span class="line">    &#125; <span class="comment">// 被提升到作用域顶部</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg); <span class="comment">// 输出hello</span></span><br><span class="line">&#125;; </span><br><span class="line">testOrder(<span class="string">'hi'</span>);</span><br><span class="line"><span class="comment">/* 输出：</span><br><span class="line">hi </span><br><span class="line">function a() &#123;</span><br><span class="line">        console.log('fun');</span><br><span class="line">    &#125;</span><br><span class="line">10 </span><br><span class="line">hello </span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>相信上面的例子已经把意思阐述清楚了。但记住3个例外：</p>
<ul>
<li><p>内置的变量名 <code>arguments</code> 表现有点奇怪。它似乎在形参之后被声明，但在函数声明之前。这意味着如果一个形参叫<code>arguments</code>，那么这个形参的优先级比<code>arguments</code>要高（覆盖了内置的<code>arguments</code>，即使它是<code>undefined</code>）。请不要把形参命名为<code>arguments</code>。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span>(<span class="params">arguments, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">arg(<span class="string">'hi'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：hi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在任何地方试图把<code>this</code>作为标识符（<code>identifier</code>，可以理解为变量名）都会报错。</p>
</li>
<li>如果多个形参同名，最后一个同名形参优先级高，即使它是<code>undefined</code>。</li>
</ul>
<h2 id="How_to_Code_With_This_Knowledge">How to Code With This Knowledge</h2><p>强烈建议一个作用域只使用一个<code>var</code>语句，而且在作用域顶部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*jslint onevar: true [...] */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>,</span><br><span class="line">        bar,</span><br><span class="line">        baz = <span class="string">"something"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="What_the_Standard_Says">What the Standard Says</h2><p><a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" target="_blank" rel="external">「ECMAScript262 Standard」</a>，section 12.2.2：</p>
<blockquote>
<p>If the variable statement occurs inside a FunctionDeclaration, the variables are defined with function-local scope in that function, as described in section 10.1.3. Otherwise, they are defined with global scope (that is, they are created as members of the global object, as described in section 10.1.3) using property attributes { DontDelete }. Variables are created when the execution scope is entered. A Block does not define a new execution scope. Only Program and FunctionDeclaration produce a new scope. Variables are initialised to undefined when created. A variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇是<a href="/frontend/2014/10/javascript-hoisting/">「JavaScript Hoisting」</a>的进阶篇，参照了大牛<strong>Ben</strong>的<a href="http://www.adequatel]]>
    </summary>
    
      <category term="hoisting" scheme="http://creeperyang.github.io/tags/hoisting/"/>
    
      <category term="scoping" scheme="http://creeperyang.github.io/tags/scoping/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Hoisting]]></title>
    <link href="http://creeperyang.github.io/2014/10/javascript-hoisting/"/>
    <id>http://creeperyang.github.io/2014/10/javascript-hoisting/</id>
    <published>2014-10-23T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>先给一个高大上的术语「JavaScript Hoisting」——没听过的人可能是一头雾水，理解的人则可能会心一笑。hoist是提升的意思（<a href="http://fanyi.baidu.com/#en/zh/hoist" target="_blank" rel="external">百度翻译</a>）：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">hoist：</span><br><span class="line">-----------------------</span></span><br><span class="line">vt.升起，提起; </span><br><span class="line">vi.被举起或抬高; </span><br><span class="line">n.起重机，升降机; 升起; &lt;俚&gt;推，托，举;</span><br></pre></td></tr></table></figure>
<p>但知道这个单词可能无助于理解这个术语。但一贯地，我认为概念可以提纲契领，所以定义先来：</p>
<blockquote>
<p>Hoisting is JavaScript’s default behavior of moving all declarations to the top of the current scope (to the top of the current script or the current function).</p>
</blockquote>
<!--view-break-->
<p><em>在js中，解释器默认会把所有的（变量/函数）声明提升到当前作用域的顶部，这就叫hoisting。</em></p>
<h3 id="Variable_Hoisting">Variable Hoisting</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceError: undefinedVariable is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(undefinedVariable);</span><br></pre></td></tr></table></figure>
<p>当我们访问未定义的变量时，会报ReferenceError，这很正常，再看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(definedBelowVariable); <span class="comment">// output --&gt; undefined </span></span><br><span class="line"><span class="keyword">var</span> definedBelowVariable = <span class="string">'I am defined here.'</span>;</span><br></pre></td></tr></table></figure>
<p>看到这段代码的输出，这一小节要讲的<code>Variable Hoisting</code>已经清晰了。在js中，变量的声明可以在使用之后，换句话说，变量可以先使用再声明。<strong>但注意：变量的初始化不会提升（hoisting）。</strong></p>
<p>所以上面的代码相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> definedBelowVariable; <span class="comment">// Variable Hoisting</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(definedBelowVariable); <span class="comment">// output --&gt; undefined </span></span><br><span class="line"></span><br><span class="line">definedBelowVariable = <span class="string">'I am defined here.'</span>; <span class="comment">// 初始化不会提升</span></span><br></pre></td></tr></table></figure>
<h3 id="Function_Hoisting">Function Hoisting</h3><p>js中函数定义（define）要用<code>function</code>关键词，定义有两种方式：函数声明或者函数表达式。</p>
<ol>
<li><p>函数声明（function declaration）</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">    code to be executed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式（function expression）</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>了解了函数定义的两种方式，再从例子中看函数提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isItHoisted(); <span class="comment">// Outputs: "Yes!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isItHoisted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Yes!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，函数被提升了，即函数定义可以在函数使用之后。<strong>但请注意：Function Hoisting仅适用于使用函数声明方式定义的函数。</strong>这是我要分开讲变量提升和函数提升的一个重要原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outputs: "Definition hoisted!"</span></span><br><span class="line">definitionHoisted();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">definitionNotHoisted();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">definitionHoisted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Definition hoisted!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> definitionNotHoisted = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Definition not hoisted!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出：<code>definitionNotHoisted</code>的声明被提升了，所以是<code>undefined</code>;但函数定义没有提升，所以是<code>TypeError</code>。</p>
<p>你可能想知道当你使用命名的函数表达式会怎么样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceError: funcName is not defined</span></span><br><span class="line">funcName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">varName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varName = <span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Definition not hoisted!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然，当命名的函数作为函数表达式的一部分时，不会被提升。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://designpepper.com/blog/drips/variable-and-function-hoisting" target="_blank" rel="external">http://designpepper.com/blog/drips/variable-and-function-hoisting</a></li>
<li><a href="http://www.w3schools.com/js/js_function_definition.asp" target="_blank" rel="external">http://www.w3schools.com/js/js_function_definition.asp</a></li>
<li><a href="http://www.w3schools.com/js/js_hoisting.asp" target="_blank" rel="external">http://www.w3schools.com/js/js_hoisting.asp</a></li>
<li><a href="http://stackoverflow.com/questions/26542361/javascript-scopes#26542456" target="_blank" rel="external">http://stackoverflow.com/questions/26542361/javascript-scopes#26542456</a></li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>先给一个高大上的术语「JavaScript Hoisting」——没听过的人可能是一头雾水，理解的人则可能会心一笑。hoist是提升的意思（<a href="http://fanyi.baidu.com/#en/zh/hoist" target="_blank" rel="]]>
    </summary>
    
      <category term="declaration" scheme="http://creeperyang.github.io/tags/declaration/"/>
    
      <category term="function" scheme="http://creeperyang.github.io/tags/function/"/>
    
      <category term="hoisting" scheme="http://creeperyang.github.io/tags/hoisting/"/>
    
      <category term="variable" scheme="http://creeperyang.github.io/tags/variable/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs Modules]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-module/"/>
    <id>http://creeperyang.github.io/2014/09/angular-module/</id>
    <published>2014-09-25T16:00:00.000Z</published>
    <updated>2015-07-02T15:17:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是模块">什么是模块</h2><p>你可以把模块当作你app不同部分（控制器、指令、过滤器等等）的容器。</p>
<h2 id="为什么需要模块">为什么需要模块</h2><p>大多应用有个main方法实例化app的各个部分并把它们联系起来。</p>
<p>angular app没有main方法。作为代替，模块声明性地指定一个app怎么启动。这样做的几个优点：</p>
<ul>
<li>声明性的处理更易理解;</li>
<li>可以打包代码作为可复用模块;</li>
<li>因为模块的延迟执行，不同模块可以以任意顺序（甚至并行）加载;</li>
<li>单元测试更快;</li>
<li>端到端测试可以用模块来覆写配置。</li>
</ul>
<!--view-break-->
<h2 id="基础(The_Basics)">基础(The Basics)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-app</span>=<span class="value">"myApp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">    &#123; &#123; 'World' | greet &#125; &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="actionscript"></span><br><span class="line">    <span class="keyword">var</span> myAppModule = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"></span><br><span class="line">    myAppModule.filter(<span class="string">'greet'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'hello, '</span> + name + <span class="string">'!'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>module</code> API;</li>
<li><code>&lt;div ng-app=&quot;myApp&quot;&gt;</code>引用<code>myApp</code>模块。这是用<code>myApp</code>模块启动应用。</li>
<li><code>angular.module(&#39;myApp&#39;, [])</code>的空数组是<code>myApp</code>的依赖。</li>
</ul>
<h2 id="推荐形式">推荐形式</h2><p>上面的例子是简单的，但不容易适配大型应用。相反，我们推荐你把app分解成多个模块：</p>
<ul>
<li>每个特性一个模块</li>
<li>每个可重用组件一个模块（特别是指令和过滤器）</li>
<li>app级别的模块依赖上面的模块，并可以包括任意初始化代码。</li>
</ul>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/sfd5ag20/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="模块加载和依赖">模块加载和依赖</h2><p>模块是<code>configuration</code>和<code>run</code>块（blocks）的集合，这些块在app启动阶段被应用到app。最简形式时，模块由两种block的集合组成：</p>
<ul>
<li>配置blocks：在provider registrations 和 configuration阶段执行。只有provider和常数可以注入配置block。这可以防止在（服务的）所有的配置完成前，服务被初始化。</li>
<li>运行blocks：在注入器被创建并用来启动app之后执行。只有实例和常数可以注入到运行block。这可以防止运行阶段做更多配置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'myModule'</span>, []).</span><br><span class="line">config(<span class="function"><span class="keyword">function</span>(<span class="params">injectables</span>) </span>&#123; <span class="comment">// provider-injector</span></span><br><span class="line">  <span class="comment">// This is an example of config block.</span></span><br><span class="line">  <span class="comment">// You can have as many of these as you want.</span></span><br><span class="line">  <span class="comment">// You can only inject Providers (not instances)</span></span><br><span class="line">  <span class="comment">// into config blocks.</span></span><br><span class="line">&#125;).</span><br><span class="line">run(<span class="function"><span class="keyword">function</span>(<span class="params">injectables</span>) </span>&#123; <span class="comment">// instance-injector</span></span><br><span class="line">  <span class="comment">// This is an example of a run block.</span></span><br><span class="line">  <span class="comment">// You can have as many of these as you want.</span></span><br><span class="line">  <span class="comment">// You can only inject instances (not Providers)</span></span><br><span class="line">  <span class="comment">// into run blocks</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="配置block">配置block</h3><p>有些快捷方法等同于<code>config</code> block，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'myModule'</span>, []).</span><br><span class="line">value(<span class="string">'a'</span>, <span class="number">123</span>).</span><br><span class="line">factory(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span>; &#125;).</span><br><span class="line">directive(<span class="string">'directiveName'</span>, ...).</span><br><span class="line">filter(<span class="string">'filterName'</span>, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is same as</span></span><br><span class="line"></span><br><span class="line">angular.module(<span class="string">'myModule'</span>, []).</span><br><span class="line">config(<span class="function"><span class="keyword">function</span>(<span class="params">$provide, $compileProvider, $filterProvider</span>) </span>&#123;</span><br><span class="line">  $provide.value(<span class="string">'a'</span>, <span class="number">123</span>);</span><br><span class="line">  $provide.factory(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">123</span>; &#125;);</span><br><span class="line">  $compileProvider.directive(<span class="string">'directiveName'</span>, ...);</span><br><span class="line">  $filterProvider.register(<span class="string">'filterName'</span>, ...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>当启动时，angular首先应用所有的常数定义;然后以注册时顺序应用配置block。</em></p>
<h3 id="运行block">运行block</h3><p>运行block是angular中最接近main方法的东西。运行block是需要运行来启动app的代码。</p>
<p>运行block在所有服务被注册，injector被创建之后执行。运行block一般包含一些难以单元测试的代码。</p>
<h3 id="依赖">依赖</h3><p>模块可以把其它模块作为依赖。作为依赖的模块必须在依赖它的模块之前加载。</p>
<p>每个模块只加载一次，即使一个模块被很多其它模块依赖。</p>
<h3 id="异步加载">异步加载</h3><p>模块是管理$injector配置的一种方式，并且与加载脚本到VM无关。有其他已存在的方案来管理脚本，可以与angular合作。因为模块在加载时什么都不做，所以它们可以以任意顺序加载。</p>
<h3 id="创建与检索">创建与检索</h3><p>注意使用<code>angular.module(&#39;myModule&#39;, [])</code>会创建<code>myModule</code>，并覆盖已经存在的同名模块。使用<code>angular.module(&#39;myModule&#39;)</code>检索模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = angular.module(<span class="string">'myModule'</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add some directives and services</span></span><br><span class="line">myModule.service(<span class="string">'myService'</span>, ...);</span><br><span class="line">myModule.directive(<span class="string">'myDirective'</span>, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// overwrites both myService and myDirective by creating a new module</span></span><br><span class="line"><span class="keyword">var</span> myModule = angular.module(<span class="string">'myModule'</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// throws an error because myOtherModule has yet to be defined</span></span><br><span class="line"><span class="keyword">var</span> myModule = angular.module(<span class="string">'myOtherModule'</span>);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是模块">什么是模块</h2><p>你可以把模块当作你app不同部分（控制器、指令、过滤器等等）的容器。</p>
<h2 id="为什么需要模块">为什么需要模块</h2><p>大多应用有个main方法实例化app的各个部分并把它们联系起来。</p>
<p>a]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="module" scheme="http://creeperyang.github.io/tags/module/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs Scope]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-scope/"/>
    <id>http://creeperyang.github.io/2014/09/angular-scope/</id>
    <published>2014-09-24T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>上一章末尾已经讲到了scope，其它地方也或多或少接触到了scope，这一章就来具体讲讲scope。</p>
<h2 id="什么是scope">什么是scope</h2><p>scope是一个对象。scope是一个引用模型（refer to model）的对象。scope是一个提供给表达式的执行环境。scope是以层次结构来组织的，模拟了app的DOM结构。scope能检测表达式和传播事件。</p>
<blockquote>
<p>scope is an object that refers to the application model. It is an execution context for expressions. Scopes are arranged in hierarchical structure which mimic the DOM structure of the application. Scopes can watch expressions and propagate events.</p>
</blockquote>
<!--view-break-->
<h3 id="Scope的特性（characteristics）">Scope的特性（characteristics）</h3><ol>
<li>scope提供API（<code>$watch</code>）观察模型的变化。</li>
<li>scope提供API（<code>$apply</code>）把模型在”Angular realm”之外发生的变化从系统传播给视图。”Angular realm”，angular范围，指controllers, services, Angular event handlers。</li>
<li>scope提供执行环境，给表达式计算时使用。如<code>{ { username } }</code>是无意义的，除非指定到特定的scope（scope上定义了<code>username</code>）上执行时才有意义。</li>
<li>scope可以嵌套来限制对app组件属性的访问，同时也提供对共享模型属性的访问。嵌套的scope不是<code>child scope</code>就是<code>isolated scope</code>。<code>child scope</code>（原型式地）继承<code>parent scope</code>的属性。<code>isolated scope</code>不继承。</li>
</ol>
<h3 id="Scope_as_Data-Model">Scope as Data-Model</h3><p>scope是控制器和视图之间的“胶水”。在模板编译的<em>linking阶段</em>，指令在scope上建立<code>$watch</code>表达式。<code>$watch</code>允许指令在属性变化时收到通知，然后可以把更新过的值渲染到视图。</p>
<p>控制器和指令都有scope的引用（have reference to the scope），但它们两者之间没有。这种安排隔离了控制器和指令，同样隔离了控制器和DOM。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController"</span>&gt;</span></span><br><span class="line">  Your name:</span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">'sayHello()'</span>&gt;</span>greet<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line">  &#123; &#123;greeting&#125; &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  angular.module(<span class="string">'scopeExample'</span>, [])</span><br><span class="line">  .controller(<span class="string">'MyController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$scope</span>.username = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$scope</span>.sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="variable">$scope</span>.greeting = <span class="string">'Hello '</span> + <span class="variable">$scope</span>.username + <span class="string">'!'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中注意到，<code>MyController</code>为scope的<code>username</code>属性赋值<code>World</code>。scope之后就通知<code>input</code>这个赋值，然后就会为<code>input</code>预先填充username再渲染。这演示了控制器怎么向scope写数据。</p>
<p>同样，控制器也可以向scope添加行为（<code>sayHello</code>）。</p>
<p>逻辑上<code>{ {greeting} }</code>的渲染包括2步：</p>
<ol>
<li>检索<code>{ {greeting} }</code>在模板中定义位置所在的DOM node的相关scope。在例子中，该scope就是传给<code>MyController</code>的scope。</li>
<li>以上面找到的scope为上下文执行<code>greeting</code>表达式，把值传给DOM。</li>
</ol>
<p>你可以把scope和它的属性视作用来渲染视图的数据。scope是与视图有关的所有事的唯一source-of-truth。</p>
<p>控制器与视图的分离是必要的，特别是有利于测试。</p>
<h3 id="Scope分层/继承（Hierarchies）">Scope分层/继承（Hierarchies）</h3><p>每个angular应用有且只有一个<code>root scope</code>，但也许有多个子scope。</p>
<p>每个app可以有多个scope，因为一些指令会创建新的子scope（参见指令文档去看哪些指令会创建新的scope）。当新的scope被创建，它们以父scope的孩子被添加。这样就创建了一棵树，平行于它们被attach到的DOM。</p>
<ol>
<li>当angular执行<code>{ {name} }</code>时，它首先查询给定元素相关的scope的name属性。</li>
<li>如果没有找到，它会查询父scope直到root scope。这就是js中的原型继承。</li>
</ol>
<iframe width="100%" height="240" src="http://jsfiddle.net/creeper/6xt2psh7/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p><strong>注意</strong>：angular会自动在元素上添加<code>ng-scope</code>类，如果这个元素被附加scope的话。</p>
<h3 id="Retrieving_Scopes_from_the_DOM">Retrieving Scopes from the DOM</h3><p>scope会被以<code>$scope</code>data属性附加到DOM上，这可以用来debug时检索（在应用中用这种方法检索scope的不多见）。<code>root scope</code>附加的DOM就是<code>ng-app</code>所在的DOM。</p>
<p>调试时可以这么检索DOM的scope：</p>
<ol>
<li><code>inspect element</code>对应的DOM;</li>
<li><code>$0</code>代表这个DOM;</li>
<li><code>angular.element($0).scope()</code>。</li>
</ol>
<h3 id="Scope_Events_Propagation">Scope Events Propagation</h3><p>Scopes可以以类似DOM事件的方式传播事件. 事件可以被broadcasted到scope children或者emitted到scope parents.</p>
<h2 id="Scope生命周期">Scope生命周期</h2><p>浏览器接收到事件的正常处理流程是：执行对应的JS回调。一旦回调结束，浏览器重新渲染DOM并且返回以等待更多事件。</p>
<p>当浏览器在angular执行上下文以外执行JS代码，这意味着angular不再知道模型的变化。正确处理模型变化应该是用<code>$apply</code>进入angular执行上下文，只有这样angular才会知道模型的变化。</p>
<p>在计算完表达式后，<code>$apply</code>方法会执行一个<code>$digest</code>。在$digest阶段，scope会检查所有的<code>$watch</code>表达式，并与之前的值比较。这种脏检查是异步执行的。这意味着<code>$scope.username=&quot;angular&quot;</code>这种赋值不会立即通知<code>$watch</code>，而是延迟等到<code>$digest</code>阶段才通知。这种延迟是必要的，因为这可以把多个模型更新合并到一个<code>$watch</code>通知，而且还保证了在<code>$watch</code>通知时不会有其它的<code>$watch</code>运行。如果一个<code>$watch</code>改变了模型的值，那么会强制额外的一个<code>$digest</code>循环。</p>
<ol>
<li><p>Creation</p>
<p> <code>root scope</code>在app bootstrap时被<code>$injector</code>创建。在模板linking阶段，一些指令会创建新的子scope。</p>
</li>
<li><p>Watcher registration</p>
<p> 在模板linking时，指令会在scope上注册watches。这些watches被用来把模型的值传给DOM。</p>
</li>
<li><p>Model mutation（变化）</p>
<p> 模型变化要被正确检测到，你应该用<code>scope.$apply()</code>。angular的API都内置这种做法，所以当你在控制器内部做同步工作时不需要<code>$apply</code>调用，另外异步的<code>$http, $timeout or $interval</code>也不需要。</p>
</li>
<li><p>Mutation observation（变化观察）</p>
<p> 在<code>$apply</code>结束时，angular会在<code>root scope</code>上启动一个<code>$digest</code> cycle，这个<code>$digest</code>之后会传播到所有子scope。在<code>$digest</code> cycle，所有<code>$watch</code>ed表达式或者函数被检查来判断模型是否变化了;如果一个变化被探测到，<code>$watch</code>的listener被调用。</p>
</li>
<li><p>Scope destruction</p>
<p> 当子scope不再需要，子scope的创建者有责任去通过<code>scope.$destroy()</code>API去destroy这些scope。这会阻止<code>$digest</code>的传播进入子scope并且允许垃圾收集器收回这个子scope的内存占用。</p>
</li>
</ol>
<h3 id="Scopes_and_Directives">Scopes and Directives</h3><p>在编译阶段，编译器匹配DOM模板的指令。指令通常可以分为2个类型：</p>
<ul>
<li>观察型指令（<em>Observing directives</em>）,如双括号表达式<code>{ {expression} }</code>，它会用<code>$watch()</code>方法注册listeners。这种类型的指令在任何时候表达式（值）改变时必须被通知以便它能更新视图。</li>
<li>监听型指令（<em>Listener directives</em>）,如<code>ng-click</code>，在DOM上注册listener。当DOM listener触发，指令执行相关的表达式并用<code>$apply()</code>方法更新视图。</li>
</ul>
<h3 id="Directives_that_Create_Scopes">Directives that Create Scopes</h3><p>在大多情况下，指令和scope交互但不会创建scope的新实例。然而，一些指令，比如<code>ng-controller</code>和<code>ng-repeat</code>，创建新的子scopes并且附加（attach）这个子scope到相应的DOM元素。</p>
<p>你可以调用<code>angular.element(aDomElement).scope()</code>为任何DOM元素检索scope。</p>
<h3 id="Controllers_and_Scopes">Controllers and Scopes</h3><p>scope和controller有以下交互方式：</p>
<ul>
<li>控制器用scope暴露方法给模板;</li>
<li>控制器定义能改变模型的方法/行为;</li>
<li>控制器可以在模型上注册watches。这些watches会在控制器行为执行后立即执行。</li>
</ul>
<h3 id="Scope_$watch_Performance_Considerations（注意事项）">Scope <code>$watch</code> Performance Considerations（注意事项）</h3><p>scope属性改变的脏检查是angular常用的操作，所以脏检查必须高效。</p>
<p>脏检查一定不能做任何DOM访问，因为DOM访问比JS对象的属性访问慢很多很多。</p>
<h2 id="Integration_with_the_browser_event_loop">Integration with the browser event loop</h2><p>下面的草图和例子描述了angular怎么和浏览器的事件回环交互。</p>
<p><img src="https://docs.angularjs.org/img/guide/concepts-runtime.png" alt="event loop"></p>
<ol>
<li>浏览器的事件loop等待一个事件发生。事件可能是用户交互、timer事件或者网络事件（服务器response）。</li>
<li>事件回调执行。这时进入JS上下文（JavaScript context）。回调可以改变DOM结构。</li>
<li>一旦回调执行完，浏览器离开JS上下文并根据DOM变化重新渲染视图。</li>
</ol>
<p>angular通过提供自己的事件处理回环改变了正常的JavaScript流程。这把JavaScript分为经典的和angular的执行上下文。只有应用在angular执行上下文的操作可以利用angular的数据绑定、异常处理、属性监测等等。你也可以用<code>$apply()</code>从js执行上下文进入angular执行上下文。</p>
<p><strong>注意</strong>：大多情况下，angular已经为你调用了<code>$apply</code>。只有实现自定义事件回调、第三方库回调时才会需要显示调用<code>$apply</code>。</p>
<ol>
<li>调用<code>scope.$apply(stimulusFn)</code>可以进入angular执行上下文，<code>stimulusFn</code>是你希望在angular执行上下文中做的工作。</li>
<li>angular执行<code>stimulusFn</code>，一般是修改app状态。</li>
<li>angular进入<code>$digest</code>回环。这个回环由两个小的回环组成，一个处理<code>$evalAsync</code> queue，一个处理<code>$watch()</code> list。<code>$digest</code>回环一直重复（keeps iterating）直到模型稳定，即<code>$evalAsync</code> queue为空而且<code>$watch()</code> list探测不到任何改变。</li>
<li><code>$evalAsync</code> queue用来安排需要在当前栈帧（<code>current stack frame</code>）外，但必须在浏览器视图渲染前发生的工作。这通常用<code>setTimeout(0)</code>来做，但<code>setTimeout(0)</code>可能比较慢，还可能引起视图闪烁，因为浏览器在每个事件之后都会渲染视图。（The $evalAsync queue is used to schedule work which needs to occur outside of current stack frame, but before the browser’s view render. This is usually done with setTimeout(0), but the setTimeout(0) approach suffers from slowness and may cause view flickering since the browser renders the view after each event.）</li>
<li><code>$watch()</code> list是一系列可能在上个循环后值改变的表达式。如果改变被探测到，<code>$watch</code>函数通常会以新值更新视图。</li>
<li>一旦angular<code>$digest</code>回环结束，则离开angular执行上下文，回到JS上下文。之后会跟着浏览器重新渲染视图。</li>
</ol>
<p><code>hello world</code>例子的解释。</p>
<ol>
<li><p>在编译阶段</p>
<ul>
<li><code>ng-model</code>和<code>input directive</code>在<code>&lt;input&gt;</code>上建立<code>keydown</code> listener。</li>
<li><code>interpolation</code>建立一个<code>$watch</code>（<code>name</code>属性变化时被通知）。</li>
</ul>
</li>
<li><p>在运行阶段</p>
<ol>
<li>按下<code>X</code>键，浏览器在<code>&lt;input&gt;</code>上emit <code>keydown</code>事件;</li>
<li><code>input directive</code>捕获input元素值的改变，调用<code>$apply(&quot;name = &#39;X&#39;;&quot;)</code>在angular上下文下更新模型;</li>
<li>angular把<code>name = &#39;X&#39;;</code>应用到模型;</li>
<li><code>$digest</code>回环启动;</li>
<li><code>$watch()</code> list探测到<code>name</code>属性上的变动，通知<code>interpolation</code>，它会更新DOM;</li>
<li>angular退出执行上下文，释放<code>keydown</code>事件给JS上下文;</li>
<li>浏览器重新渲染视图，更新文字。</li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一章末尾已经讲到了scope，其它地方也或多或少接触到了scope，这一章就来具体讲讲scope。</p>
<h2 id="什么是scope">什么是scope</h2><p>scope是一个对象。scope是一个引用模型（refer to model）的对象。scope]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="scope" scheme="http://creeperyang.github.io/tags/scope/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs HTML Compiler]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-html-compiler/"/>
    <id>http://creeperyang.github.io/2014/09/angular-html-compiler/</id>
    <published>2014-09-23T16:00:00.000Z</published>
    <updated>2015-07-02T15:17:02.000Z</updated>
    <content type="html"><![CDATA[<p>html编译，这是angular的核心概念或者说重难点。这章就是围绕<code>HTML Compiler</code>展开，既算是自定义指令的深入，也算是对angular工作原理的一点解析。</p>
<p>首先<strong>注意</strong>：如果只是初学者，或者暂时不想深入，那么，跳过本章也可。</p>
<!--view-break-->
<h2 id="概览">概览</h2><p>angular的<code>HTML Compiler</code>允许开发人员教会浏览器新语法。编译器允许你为元素或属性添加新行为，甚至创建有自定义行为的新元素或新属性。<strong>angular称这些行为扩展（behavior extensions）为指令。</strong></p>
<p>HTML有许多结构以声明的方式来为静态文档格式化html。（HTML has a lot of constructs for formatting the HTML for static documents in a declarative fashion.）例如，元素居中，不需要提供命令让浏览器计算中心的位置，为元素加上<code>align=&quot;center&quot;</code>的属性就够了。这就是声明式语言的强大。</p>
<p>但声明式语言有时又是受限的，因为它不允许你教浏览器新语法。比如，你想让文本居中变成1/3对齐就比较难了。所以需要教浏览器新语法。</p>
<p>angular自带通用的指令，编写webapp时很有用。但你可以自定义指令。这些指令就是构建你app的“特定领域语言”（<em>Domain Specific Language</em>）。</p>
<p>所有的编译发生在浏览器端，无关服务器。</p>
<h2 id="编译器">编译器</h2><p>编译器是一个angular服务，它会遍历DOM来查询属性。</p>
<blockquote>
<p>Compiler is an Angular service which traverses the DOM looking for attributes.</p>
</blockquote>
<p>编译过程分为2个阶段：</p>
<ol>
<li>编译（<em>Compile</em>）：遍历DOM，收集这个DOM上的所有指令。结果是一个link函数。</li>
<li>链接（<em>Link</em>）：用scope结合指令，生成动态视图。scope model的所有变动会影响视图，视图上的任何用户交互会影响scope model。这让scope model成为<em>single source of truth</em>。</li>
</ol>
<p>一些指令如<code>ng-repeat</code>会为集合的每个元素克隆DOM元素。把编译分为compile和link两个过程有利于提高性能。因为克隆的模板只需要编译一次，然后为每个克隆实例link。</p>
<h2 id="指令">指令</h2><p>指令是一种行为（behavior），当编译过程中遇到特定html结构时会被触发。指令可以放在元素名、属性、类名和注释上。</p>
<p><strong>指令就是一个函数，编译器在DOM中遇到指令时执行它。</strong></p>
<h2 id="理解视图">理解视图</h2><p>大多模板系统是单向绑定，获取（consume）静态字符串模板，与数据结合，得出新字符串，插入元素内部（<code>innerHTML</code>）。</p>
<p>这意味着数据的任意改变需要重新与template结合编译，然后插入元素。这样做有些问题：</p>
<ul>
<li>读取用户输入，合并到数据</li>
<li>通过重写会严重影响用户输入（clobbering user input by overwriting it）</li>
<li>控制整个更新过程</li>
<li>缺乏行为表现力（lack of behavior expressiveness）</li>
</ul>
<p>angular不同。angular编译器接收（consume）DOM，不是字符串模板。结果是link函数，该函数与scope model结合生成live view。这个view和scope model绑定是透明的，开发者不用做任何事去更新视图。然后因为没有用到<code>innerHTML</code>，所以你不会影响到用户输入。更多的是，angular指令不仅包括文字绑定，还包括行为结构。</p>
<p>angular会生成稳定的DOM。绑定到模型的DOM元素实例在整个绑定期间不会变。这意味着可以访问到元素和注册事件处理，并且知道引用不会被模板数据合并破坏。</p>
<h2 id="指令怎么被编译？">指令怎么被编译？</h2><p><strong>再次强调一点：angular在DOM节点上操作而不是字符串！</strong>通常你是不会注意到这个限制的，因为当页面加载，浏览器会自动解析html为DOM。</p>
<p>html编译有3个阶段：</p>
<ol>
<li><p><code>$compile</code>遍历DOM并匹配指令（traverses the DOM and matches directives）</p>
<p>如果编译器找到一个元素匹配指令，那么， 这个指令就会被添加到匹配这个DOM元素的指令列表。单个DOM元素可能匹配多个指令。</p>
</li>
<li><p>一旦所有匹配这个DOM元素的指令都被标识出了，编译器按优先级<code>priority</code>排序它们。</p>
<p> 每个指令的<code>compile</code>函数被执行。每个<code>compile</code>函数都有一次机会修改DOM。每个<code>compile</code>函数返回一个<code>link</code>函数。这些<code>link</code>函数被组合成一个复合<code>link</code>函数（调用每个小<code>link</code>）。</p>
</li>
<li><p><code>$compile</code>通过调用之前的复合<code>link</code>函数，把模板链接到scope。这会轮流调用每个小<code>link</code>函数，注册监听器，启动<code>$watch</code>s。</p>
</li>
</ol>
<p>编译的结果是scope和DOM之间的动态绑定。因为这点，编译后的scope上的模型的任何变化都会反映到视图上。</p>
<hr>
<p><em>这里的遍历DOM，指的不是整个DOM树，而是DOM节点。如下面的<code>&lt;div ng-bind=&quot;exp&quot;&gt;&lt;/div&gt;</code>。</em></p>
<hr>
<p>下面是使用<code>$compile</code>服务的对应代码，这应该会让你了解angular内部做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $compile = ...; <span class="comment">// injected into your code</span></span><br><span class="line"><span class="keyword">var</span> scope = ...;</span><br><span class="line"><span class="keyword">var</span> parent = ...; <span class="comment">// DOM element where the compiled template can be appended</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">'&lt;div ng-bind="exp"&gt;&lt;/div&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: parse HTML into DOM element</span></span><br><span class="line"><span class="keyword">var</span> template = angular.element(html);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: compile the template</span></span><br><span class="line"><span class="keyword">var</span> linkFn = $compile(template);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: link the compiled template with the scope.</span></span><br><span class="line"><span class="keyword">var</span> element = linkFn(scope);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Append to DOM (optional)</span></span><br><span class="line">parent.appendChild(element);</span><br></pre></td></tr></table></figure>
<h3 id="Compile和Link的不同之处">Compile和Link的不同之处</h3><p>到这里你可能要问编译过程为什么要分为compile和link两个过程。简单点说，任何时候模型中的变化会导致<strong>DOM结构(structure of the DOM)</strong>的变化，那么compile和link的分离就是必要的。</p>
<p>指令很少会有<code>compile function</code>，因为大多情况下，指令被考虑到工作在特定结构的DOM而不是改变DOM结构。</p>
<p>指令一般都有<code>link function</code>，link函数允许指令注册监听器到特定的克隆的DOM元素实例，而不是改变DOM结构。</p>
<p><strong>注意</strong>：出于性能考虑，任何可被指令实例共享（shared among the instance of directives）的操作应该放到compile函数中。</p>
<h4 id="“Compile”_Vs_“Link”的一个例子">“Compile” Vs “Link”的一个例子</h4><p>为了理解，以真实的<code>ngRepeat</code>为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123; &#123;user.name&#125; &#125;, you have these actions:</span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"action in user.actions"</span>&gt;</span></span><br><span class="line">    &#123; &#123; action.description &#125; &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当上面这个例子被编译时，编译器访问每个节点并查找指令。</p>
<p><code>{ {user.name} }</code>匹配<code>interpolation</code>指令，而<code>ng-repeat</code>匹配<code>ngRepeat</code>指令。</p>
<p>但<code>ngRepeat</code>有个问题：</p>
<p>它需要为<code>user.actions</code>中的每个<code>action</code>克隆新的<code>&lt;li&gt;</code>元素。这乍一看没什么特别的，但考虑到<code>user.actions</code>以后可能会添加项目，情况变得复杂了。这意味着为了（以后的）克隆，需要保存一份干净的<code>&lt;li&gt;</code>元素拷贝。</p>
<p>当新的<code>action</code>被添加，模板<code>&lt;li&gt;</code>元素需要被克隆并插入到<code>ul</code>。但克隆<code>&lt;li&gt;</code>是不够的，还需要编译<code>&lt;li&gt;</code>，这样它的指令，如<code>{ { action.description } }</code>，才能在正确的scope下执行。</p>
<p>解决这个问题的一个笨方法是插入一份拷贝然后编译一次这个拷贝。这样做的问题是编译这个拷贝会重复很多工作。特别的，我们不得不每次在克隆前去遍历这个<code>&lt;li&gt;</code>来查找它的指令。这会有性能问题。</p>
<p>解决方案是把编译分成compile和link：</p>
<ol>
<li>compile阶段，所有指令都被识别，并被按优先级排序;</li>
<li>link阶段，执行有关”链接“scope的一个特定实例与<code>&lt;li&gt;</code>的一个特定实例的任何工作。</li>
</ol>
<p><strong>注意</strong>：<code>link</code>意味着在DOM上建立监听器，在scope上建立<code>$watch</code>，以保持模型和视图的同步。</p>
<blockquote>
<p>Note: <em>Link means setting up listeners on the DOM and setting up $watch on the Scope to keep the two in sync.</em></p>
</blockquote>
<p><code>ngRepeat</code>阻止编译过程下沉到<code>&lt;li&gt;</code>内，所以它能有一个原始的<code>&lt;li&gt;</code>克隆，能自己处理插入和删除节点。</p>
<p><code>ngRepeat</code>指令把编译分为compile和link。<code>&lt;li&gt;</code>元素的compile结果是一个link函数，该link函数包含了<code>&lt;li&gt;</code>元素内部的所有指令，准备被附加到一个特定的<code>&lt;li&gt;</code>元素克隆实例（ready to be attached to a specific clone of the <code>&lt;li&gt;</code> element）。</p>
<p>在运行（runtime）时，<code>ngRepeat</code>监测表达式<code>&quot;action in user.actions&quot;</code>，一旦新项目添加到数组，它会克隆<code>&lt;li&gt;</code>元素，为这个<code>&lt;li&gt;</code>元素创建一个新的<code>scope</code>，并在克隆的<code>&lt;li&gt;</code>元素上调用link函数。</p>
<h3 id="理解Scope怎么与_Transcluded_Directives协同工作">理解Scope怎么与 Transcluded Directives协同工作</h3><p>指令的一个常用情况是创建复用组件。下面是一个简化的对话框组件例子。</p>
<p>下面展示<code>dialog</code>指令怎么在html中使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html to make dialog directive work --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"show=true"</span>&gt;</span>show<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dialog</span> <span class="attribute">title</span>=<span class="value">"Hello &#123; &#123;username&#125; &#125;."</span></span><br><span class="line">        <span class="attribute">visible</span>=<span class="value">"show"</span></span><br><span class="line">        <span class="attribute">on-cancel</span>=<span class="value">"show = false"</span></span><br><span class="line">        <span class="attribute">on-ok</span>=<span class="value">"show = false; doSomething()"</span>&gt;</span></span><br><span class="line">   Body goes here: &#123; &#123;username&#125; &#125; is &#123; &#123;title&#125; &#125;.</span><br><span class="line"><span class="tag">&lt;/<span class="title">dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是<code>dialog</code>的模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-show</span>=<span class="value">"visible"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h3</span>&gt;</span>&#123; &#123;title&#125; &#125;<span class="tag">&lt;/<span class="title">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"body"</span> <span class="attribute">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"onOk()"</span>&gt;</span>Save changes<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"onCancel()"</span>&gt;</span>Close<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中<code>dialog</code>不会被正确渲染，除非对scope进行处理。一个问题是<code>dialog</code>希望模板scope的<code>title</code>属性已被定义，但我们希望<code>title</code>是<code>dialog</code>元素的title attribute的插值结果。另外，按钮希望<code>onOk</code>，<code>onCancel</code>已经在scope中存在——这会限制<code>dialog</code>指令的用处。解决方案是用<code>locals</code>来创建local变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scope: &#123;</span><br><span class="line">  title: <span class="string">'@'</span>,       <span class="comment">// the title uses the data-binding from the parent scope</span></span><br><span class="line">  onOk: <span class="string">'&amp;'</span>,        <span class="comment">// create a delegate onOk function</span></span><br><span class="line">  onCancel: <span class="string">'&amp;'</span>,    <span class="comment">// create a delegate onCancel function</span></span><br><span class="line">  visible: <span class="string">'='</span>      <span class="comment">// set up visible to accept data-binding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建local properties会有两个问题：</p>
<ol>
<li>隔离（isolation）：如果用户忘记在<code>&lt;dialog&gt;</code>上设置<code>title</code> attribute，那么dialog模板会绑定到父scope的同名属性。</li>
<li>嵌入（transclusion）：被嵌入的（ transcluded）DOM可以访问到locals，但locals可能覆写了某些属性，比如这里的<code>title</code>，但嵌入的DOM其实希望访问外部的scope。</li>
</ol>
<p>为了解决隔离问题，指令会创建一个新的<code>isolated</code> scope。<code>isolated</code> scope不继承任何父scope，所以不用担心问题一。</p>
<p>但<code>isolated</code> scope导致了新问题：被嵌入的DOM是指令的<code>isolated</code> scope的孩子，不能绑定到任何其它东西。因为这个原因，the transcluded scope 将会是原来的scope的child，在指令创建<code>isolated</code> scope之前。<strong>这使<code>isolated</code> scope和<code>transcluded</code> scope是兄弟。</strong></p>
<p>因此，最终代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">transclude: <span class="literal">true</span>,</span><br><span class="line">scope: &#123;</span><br><span class="line">    title: <span class="string">'@'</span>,             <span class="comment">// the title uses the data-binding from the parent scope</span></span><br><span class="line">    onOk: <span class="string">'&amp;'</span>,              <span class="comment">// create a delegate onOk function</span></span><br><span class="line">    onCancel: <span class="string">'&amp;'</span>,          <span class="comment">// create a delegate onCancel function</span></span><br><span class="line">    visible: <span class="string">'='</span>            <span class="comment">// set up visible to accept data-binding</span></span><br><span class="line">&#125;,</span><br><span class="line">restrict: <span class="string">'E'</span>,</span><br><span class="line">replace: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>html编译，这是angular的核心概念或者说重难点。这章就是围绕<code>HTML Compiler</code>展开，既算是自定义指令的深入，也算是对angular工作原理的一点解析。</p>
<p>首先<strong>注意</strong>：如果只是初学者，或者暂]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="compile" scheme="http://creeperyang.github.io/tags/compile/"/>
    
      <category term="compiler" scheme="http://creeperyang.github.io/tags/compiler/"/>
    
      <category term="scope" scheme="http://creeperyang.github.io/tags/scope/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs自定义指令]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-custom-directive/"/>
    <id>http://creeperyang.github.io/2014/09/angular-custom-directive/</id>
    <published>2014-09-21T16:00:00.000Z</published>
    <updated>2015-07-02T15:16:47.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/frontend/2014/09/angular-directive/">前一章</a>介绍了指令的基础知识，这一章则关注自定义指令。从一个简单的例子来看怎么自定义指令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">"myApp"</span>, [])</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">"myDirective"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   restrict: <span class="string">"A"</span>,</span><br><span class="line">   link: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(<span class="string">"I'm working"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<!--view-break-->
<h2 id="自定义指令的API和参数">自定义指令的API和参数</h2><p>像控制器一样，指令注册到模块上。指令注册API是：<code>module.directive（name, fun）</code>。</p>
<ul>
<li><code>name</code>是标准化的指令名。</li>
<li><code>fun</code>是工厂函数，返回一个对象，指定指令的行为。工厂函数只在编译器第一次匹配到该指令时调用一次，你可以在里面做些初始化工作。</li>
</ul>
<iframe width="100%" height="200" src="http://jsfiddle.net/creeper/L50h9eh1/1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>这个例子验证了工厂函数只执行一次。</p>
<h3 id="工厂函数返回的对象的参数（可设置选项）">工厂函数返回的对象的参数（可设置选项）</h3><p>下面具体讲解工厂函数返回的对象的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">myModule.directive(<span class="string">'namespaceDirectiveName'</span>, <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">injectables</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> directiveDefinitionObject = &#123;</span><br><span class="line">        restrict: string, <span class="comment">//指令的使用方式，包括标签，属性，类，注释</span></span><br><span class="line">        priority: number, <span class="comment">//指令执行的优先级</span></span><br><span class="line">        template: string, <span class="comment">//指令使用的模板，用HTML字符串的形式表示</span></span><br><span class="line">        templateUrl: string, <span class="comment">//从指定的url地址加载模板</span></span><br><span class="line">        replace: bool, <span class="comment">//是否用模板替换当前元素，若为false，则append在当前元素上</span></span><br><span class="line">        transclude: bool, <span class="comment">//是否将当前元素的内容转移到模板中</span></span><br><span class="line">        scope: bool or object, <span class="comment">//指定指令的作用域</span></span><br><span class="line">        controller: <span class="function"><span class="keyword">function</span> <span class="title">controllerConstructor</span>(<span class="params">$scope, $element, $attrs, $transclude</span>) </span>&#123;...</span><br><span class="line">        &#125;, <span class="comment">//定义与其他指令进行交互的接口函数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>: string, <span class="comment">//指定需要依赖的其他指令</span></span><br><span class="line">        link: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, iElement, iAttrs</span>) </span>&#123;...</span><br><span class="line">        &#125;, <span class="comment">//以编程的方式操作DOM，包括添加监听器等</span></span><br><span class="line">        compile: <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">tElement, tAttrs, transclude</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> :&#123;</span><br><span class="line">                pre: <span class="function"><span class="keyword">function</span> <span class="title">preLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...</span><br><span class="line">                &#125;,</span><br><span class="line">                post: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, iElement, iAttrs, controller</span>) </span>&#123;...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//编程的方式修改DOM模板的副本，可以返回链接函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> directiveDefinitionObject;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面具体解释常用的参数：</p>
<p>restrict指明了一个指令应该如何在HTML中使用，默认A，可以组合使用，如EA等。</p>
<table>
<thead>
<tr>
<th>restrict取值</th>
<th>含义</th>
<th>使用示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>标签</td>
<td><code>&lt;my-menu title=Products&gt;&lt;/my-menu&gt;</code></td>
</tr>
<tr>
<td>A</td>
<td>属性</td>
<td><code>&lt;div my-menu=Products&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td>C</td>
<td>类</td>
<td><code>&lt;div class=&quot;my-menu&quot;:Products&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td>M</td>
<td>注释</td>
<td><code>&lt;!--directive:my-menu Products--&gt;</code></td>
</tr>
</tbody>
</table>
<p><strong>什么时候用属性vs元素？</strong>当你创建组件（需要控制模板）时用元素;当你只是修饰已存在的元素，为其添加新功能时用属性。</p>
<p>template指明了当指令被Angular编译和链接时生成的HTML标记。它不一定是一个简单的字符串。template可以很复杂，其中经常会涉及其它的指令，表达式（{ {} }），等等。在大多数情况下你可能会想要使用templateUrl而不是template。因此，理想情况下你应该首先将模板放置在一个单独的HTML文件中然后让templateUrl指向它。</p>
<p>replace指明了是否生成的模板会代替绑定指令的元素。默认为false，设为true时，指令标签将会替换为template中定义的内容。</p>
<p>transclude指明了是否把绑定指令的元素的内容转移到模板中。</p>
<h2 id="Isolating_the_Scope_of_a_Directive">Isolating the Scope of a Directive</h2><p>不设置<code>scope</code>属性时，指令的scope就是父scope。</p>
<p>可以通过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">scope: &#123;</span><br><span class="line">  customerInfo: <span class="string">'=info'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>此时，指令的scope选项是对象，里面的每个属性都是isolate scope binding。</p>
<ul>
<li>name（<code>customerInfo</code>）就是指令独立的scope的属性名;</li>
<li>value（<code>=info</code>）告诉<code>$compile</code>绑定到<code>info</code>属性。</li>
</ul>
<h2 id="指令与控制器/指令的交流">指令与控制器/指令的交流</h2><h3 id="指令与控制器的交流">指令与控制器的交流</h3><p>如前一小节所示，通过scope和attribute，指令可以与外部控制器交流。这方面更多的可以看有关scope的一章。</p>
<p>下面讲通过<code>scope.$apply()</code>与外部控制器交流。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"AppCtrl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">enter</span>=<span class="value">"deleteTweets()"</span>&gt;</span>Roll over to load more tweets<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">    <span class="keyword">var</span> app = angular.module(<span class="string">'twitterApp'</span>, []);</span><br><span class="line"></span><br><span class="line">    app.controller(<span class="string">"AppCtrl"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">      <span class="variable">$scope</span>.loadMoreTweets = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="string">"Loading tweets!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable">$scope</span>.deleteTweets = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="string">"deleting tweets!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.directive(<span class="string">"enter"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(scope, element, attrs)</span> </span>&#123;</span><br><span class="line">        element.bind(<span class="string">"mouseenter"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">          scope.<span class="variable">$apply</span>(attrs.enter);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="指令间交流">指令间交流</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-app</span>=<span class="value">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">country</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">state</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">city</span>&gt;</span><span class="tag">&lt;/<span class="title">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">state</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="keyword">var</span> app = angular.module(<span class="string">"app"</span>, []);</span><br><span class="line">    app.directive(<span class="string">"country"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            restrict: <span class="string">"E"</span>,</span><br><span class="line">            controller: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.makeAnnouncement = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"Country says: "</span> + message);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    app.directive(<span class="string">"state"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            restrict: <span class="string">"E"</span>,</span><br><span class="line">            controller: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.makeLaw = <span class="function"><span class="keyword">function</span>(<span class="params">law</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"Law: "</span> + law);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    app.directive(<span class="string">"city"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            restrict: <span class="string">"E"</span>,</span><br><span class="line">            <span class="built_in">require</span>: [<span class="string">"^country"</span>,<span class="string">"^state"</span>],</span><br><span class="line">            link: <span class="function"><span class="keyword">function</span>(<span class="params">scope, element, attrs, ctrls</span>) </span>&#123;</span><br><span class="line">                ctrls[<span class="number">0</span>].makeAnnouncement(<span class="string">"This city rocks"</span>);</span><br><span class="line">                ctrls[<span class="number">1</span>].makeLaw(<span class="string">"Jump higher"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果嵌套的指令间存在分层关系（<em>hierarchical relationship</em>），那么可以通过使用控制器来在指令间交流：</p>
<ul>
<li>父指令可以通过控制器来暴露一些东西，比如这里的<code>makeAnnouncement</code>方法，并传给子指令。</li>
<li>我们可以把父指令的控制器注入到子指令中，这由<code>require</code>命名体系完成。通过这个，子指令可以使用父指令的控制器。</li>
<li>这种控制器的继承只要是祖先与后代的关系就可用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="/frontend/2014/09/angular-directive/">前一章</a>介绍了指令的基础知识，这一章则关注自定义指令。从一个简单的例子来看怎么自定义指令。</p>
<figure class="highlight javascript">]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="directive" scheme="http://creeperyang.github.io/tags/directive/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs内置指令]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-directive/"/>
    <id>http://creeperyang.github.io/2014/09/angular-directive/</id>
    <published>2014-09-19T16:00:00.000Z</published>
    <updated>2015-07-02T15:16:32.000Z</updated>
    <content type="html"><![CDATA[<p>指令是使angular特殊的基础。指令是angular这个框架最重要的部分之一。</p>
<p>指令是什么？</p>
<blockquote>
<p>At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS’s HTML compiler ($compile) to attach a specified behavior to that DOM element or even transform the DOM element and its children.</p>
</blockquote>
<!--view-break-->
<p>翻译一下，指令就是DOM元素上的标记，可以是属性、类、注释甚至元素本身。指令告诉angular的html编译器为该DOM元素附加特定行为，甚至转换该DOM元素及其后代。</p>
<h2 id="内置指令">内置指令</h2><p>angular内置许多指令，先介绍这些指令的含义及用法。</p>
<h3 id="样式相关指令">样式相关指令</h3><ol>
<li><p>ngClass</p>
<p>ng-class用来给元素绑定类名，其表达式的返回值可以是以下三种：- 类名字符串，可以用空格分割多个类名，如”redtext boldtext”；- 类名数组，数组中的每一项都会层叠起来生效；- 一个名值对应的object，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。</p>
<p>例子：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/0cn2mzwz/1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</li>
<li><p>ngStyle</p>
<p>ng-style用来绑定元素的css样式，其表达式的返回值为一个js对象，键为css样式名，值为该样式对应的合法取值。用法比较简单：</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-style</span>=<span class="value">"&#123;color:'red'&#125;"</span>&gt;</span>ng-style测试<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-style</span>=<span class="value">"style"</span>&gt;</span>ng-style测试<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">$scope.style = &#123;color:'red'&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ngShow/ngHide</p>
<p>控制显隐。表达式返回值应该是boolean。</p>
</li>
</ol>
<h3 id="表单控件功能相关的">表单控件功能相关的</h3><ul>
<li>ng-checked控制radio和checkbox的选中状态</li>
<li>ng-selected控制下拉框的选中状态</li>
<li>ng-disabled控制失效状态</li>
<li>ng-multiple控制多选</li>
<li>ng-readonly控制只读状态</li>
</ul>
<p>以上指令的取值均为boolean类型，当值为true时相关状态生效，道理比较简单就不多做解释。</p>
<p><strong>注意：</strong> 上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。</p>
<h3 id="事件绑定相关">事件绑定相关</h3><p><code>ng-change``ng-dblclick``ng-mousedown``ng-mouseenter``ng-mouseleave``ng-mousemove``ng-mouseover``ng-mouseup``ng-submit</code></p>
<p>事件绑定指令的取值为函数，并且需要加上括号，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">select</span> <span class="attribute">ng-change</span>=<span class="value">"change($event)"</span>&gt;</span><span class="tag">&lt;/<span class="title">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">    <span class="variable">$scope</span>.change = <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$event</span>)</span></span>&#123;</span><br><span class="line">        alert(<span class="variable">$event</span>.target);</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊的ng-src和ng-href">特殊的ng-src和ng-href</h3><p>我们使用ng-src指令，这样在路径被正确得到之前就不会显示找不到图片。同理，<code>&lt;a&gt;</code>标签的href属性也需要换成ng-href，这样页面上就不会先出现一个地址错误的链接。</p>
<p>ng中有一个与{ {} }等同的指令:ng-bind，同样用于单向绑定，在页面刚加载的时候就不会显示出对用户无用的数据。</p>
<h3 id="控制相关的指令">控制相关的指令</h3><p>如ngRepeat循环输出</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"o in question.options"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">b</span>&gt;</span>&#123; &#123;$index+1&#125; &#125;.<span class="tag">&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"o.content"</span> <span class="attribute">value</span>=<span class="value">"o.content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:void(0);"</span> <span class="attribute">ng-click</span>=<span class="value">"delOption($index)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Matching_Directives（匹配指令）">Matching Directives（匹配指令）</h2><p>上面都是常用的内置指令，通过一些代码，对指令的使用应该有了基本了解，这里讲一讲指令的匹配，即编译器怎么决定/找到正确的指令。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"foo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">data-ng:model</span>=<span class="value">"foo"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面两个都匹配<code>ngModel</code>指令。</p>
<p>angular标准化（<strong>normalize</strong>）元素的标签和属性名来检测匹配哪个指令。</p>
<p>我们一般通过大小写敏感的驼峰式(<em>camelCase</em>)的标准化的名字去指代指令(如<code>ngModel</code>)，但html是不区分大小写的，于是，我们一般用小写的，破折线分离（<em> dash-delimited </em>）的属性名去指代指令（如<code>ng-model</code>）。</p>
<p>标准化处理如下：</p>
<ol>
<li>去除元素/属性前的<code>x-</code>和<code>data-</code>;</li>
<li>把<code>:</code>，<code>-</code>或<code>_</code>分离的名字转换成驼峰式。</li>
</ol>
<p>如下面的例子都匹配<code>ngBind</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"Controller"</span>&gt;</span></span><br><span class="line">  Hello <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">'name'</span>&gt;</span> <span class="tag">&lt;<span class="title">hr</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng-bind</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span> <span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng:bind</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span> <span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng_bind</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span> <span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">data-ng-bind</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span> <span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">x-ng-bind</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span> <span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>最好用破折线分离的形式，如<code>ng-bind</code>，如果你想用html验证工具，也可以用<code>data-ng-bind</code>。其它形式都是历史遗留（问题）。</li>
<li>最好用标签名或者属性名，折会使angular更容易检测指令。</li>
</ul>
<h3 id="Text_and_attribute_bindings">Text and attribute bindings</h3><p>在编译期间，编译器用<code>$interpolate</code>服务去检测文本和属性是否内嵌表达式。这些表达式会被注册为<code>watches</code>，并作为正常digest循环的一部分。</p>
<p>一个例子：<code>&lt;a ng-href=&quot;img/{ {username} }.jpg&quot;&gt;Hello { {username} }!&lt;/a&gt;</code>。</p>
<h3 id="ngAttr_attribute_bindings"><code>ngAttr</code> attribute bindings</h3><p>浏览器有时会比较挑剔，对属性的值是否有效进行验证。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">circle</span> <span class="attribute">cx</span>=<span class="value">"&#123; &#123;cx&#125; &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="title">circle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>SVG DOM API</code>的限制，有时会出行错误<code>Error: Invalid value for attribute cx=&quot;{ {cx} }&quot;</code>。</p>
<p>这时，你可以使用<code>ng-attr-cx</code>修复这种错误。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>指令是使angular特殊的基础。指令是angular这个框架最重要的部分之一。</p>
<p>指令是什么？</p>
<blockquote>
<p>At a high level, directives are markers on a DOM element (such]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="directive" scheme="http://creeperyang.github.io/tags/directive/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs Forms（格式化输入）]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-forms/"/>
    <id>http://creeperyang.github.io/2014/09/angular-forms/</id>
    <published>2014-09-17T16:00:00.000Z</published>
    <updated>2015-07-02T15:15:45.000Z</updated>
    <content type="html"><![CDATA[<p>表单控件（<code>input</code>、<code>select</code>、<code>textarea</code>）是用户输入数据的途径。一个表单（form）是表单控件的集合，用来组织相关的表单控件。</p>
<p>表单和表单控件提供验证服务，所以无效输入时会提示用户。这会提高用户体验，因为用户可以获得连续的提示来改正错误。但注意，客户端的验证不能代替服务端验证，因为客户端验证容易被绕过而不太可信，必须在服务端再次验证以保证安全。</p>
<!--view-break-->
<h2 id="简单表单（Simple_form）">简单表单（Simple form）</h2><p>理解双向数据绑定的核心指令是<code>ngModel</code>。<code>ngModel</code>提供了<a href="https://docs.angularjs.org/api/ng/type/ngModel.NgModelController" target="_blank" rel="external">API</a>让其它指令扩展它的行为。下面是一个简单表单：</p>
<iframe width="100%" height="220" src="http://jsfiddle.net/creeper/4p3cczm2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>注意<code>novalidate</code>用来禁用浏览器原生的表单验证。</p>
<h2 id="使用CSS类">使用CSS类</h2><p>为了能改变控件和表单的样式，<code>ngModel</code>会添加以下CSS类：</p>
<ul>
<li><code>ng-valid</code></li>
<li><code>ng-invalid</code></li>
<li><code>ng-pristine</code></li>
<li><code>ng-dirty</code></li>
<li><code>ng-touched</code></li>
<li><code>ng-untouched</code></li>
</ul>
<p>对上面的例子做些改变：依据<code>ngModel</code>添加的css类来改变表单的样式。</p>
<iframe width="100%" height="220" src="http://jsfiddle.net/creeper/4p3cczm2/1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h2 id="Binding_to_form_and_control_state">Binding to form and control state</h2><p>A form is an instance of <a href="https://docs.angularjs.org/api/ng/type/form.FormController" target="_blank" rel="external">FormController</a>. The form instance can optionally be published into the scope using the <code>name</code> attribute.</p>
<p>相似的，一个有<code>ngModel</code>指令的input控件持有一个<code>NgModelController</code>实例。同样，有<code>name</code>属性时，Such a control instance can be published as a property of the form instance。</p>
<p>这意味着，表单、控件的内部状态is available for binding in the view using the standard binding primitives.</p>
<p>这允许我们扩展上面的例子，有以下新特性：</p>
<ul>
<li>reset按钮只有在表单有变动时可用;</li>
<li>save按钮只有在表单有变动且输入有效时可用;</li>
<li>自定义<code>user.email</code>和<code>user.agree</code>的错误信息。</li>
</ul>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/4p3cczm2/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>注意<code>name=&quot;form&quot;</code>之类name的添加，然后表达式中可以访问。</p>
<h2 id="Custom_triggers">Custom triggers</h2><p>默认情况下，内容的改变都会触发模型的更新和表单验证。但你可以通过<code>ngModelOptions</code>来覆写这种行为。</p>
<ul>
<li>比如<code>ng-model-options=&quot;{ updateOn: &#39;blur&#39; }&quot;</code>，则只在<code>blur</code>时更新和验证。</li>
<li>当然，你可以指定多个事件<code>ng-model-options=&quot;{ updateOn: &#39;mousedown blur&#39; }&quot;</code>。</li>
<li>如果你希望保留原来的事件，添加新事件，用default，<code>ng-model-options=&quot;{ updateOn: &#39;default blur&#39; }&quot;</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"ExampleController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">form</span>&gt;</span></span><br><span class="line">    Name:</span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"user.name"</span> <span class="attribute">ng-model-options</span>=<span class="value">"&#123; updateOn: 'blur' &#125;"</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    Other data:</span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"user.data"</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">pre</span>&gt;</span>username = "&#123; &#123;user.name&#125; &#125;"<span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">pre</span>&gt;</span>userdata = "&#123; &#123;user.data&#125; &#125;"<span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  angular.module(<span class="string">'customTriggerExample'</span>, [])</span><br><span class="line">  .controller(<span class="string">'ExampleController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$scope</span>.user = &#123;&#125;;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Non-immediate_(debounced)_model_updates">Non-immediate (debounced) model updates</h2><p>你可以通过在<code>ngModelOptions</code>内添加<code>debounce</code>来延迟模型的更新和验证。这种延迟同样会应用到parsers、validators和模型标志如<code>$dirty</code>、<code>$pristine</code>。</p>
<ul>
<li><code>ng-model-options=&quot;{ debounce: 500 }&quot;</code>会在最后一次内容更改后延迟500ms，然后触发模型更新和验证。</li>
<li>如果设置了Custom triggers，debounce可以对每个事件分别设置。这很有用，比如说<code>blur</code>可以立即更新。<code>ng-model-options=&quot;{ updateOn: &#39;default blur&#39;, debounce: { default: 500, blur: 0 } }&quot;</code>。</li>
</ul>
<p><em>如果这些属性被加到元素上了，它们会应用到所有子元素和控件，除非子元素和控件被覆写了。</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"ExampleController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">form</span>&gt;</span></span><br><span class="line">    Name:</span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"user.name"</span> <span class="attribute">ng-model-options</span>=<span class="value">"&#123; debounce: 250 &#125;"</span> /&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">pre</span>&gt;</span>username = "&#123; &#123;user.name&#125; &#125;"<span class="tag">&lt;/<span class="title">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  angular.module(<span class="string">'debounceExample'</span>, [])</span><br><span class="line">  .controller(<span class="string">'ExampleController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$scope</span>.user = &#123;&#125;;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Custom_Validation">Custom Validation</h2><p>angular提供了大多数html5<code>input</code>类型（text, number, url, email, radio, checkbox）的基本实现，以及一些验证指令（<code>required</code>, <code>pattern</code>, <code>minlength</code>, <code>maxlength</code>, <code>min</code>, <code>max</code>）。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/obuoms0u/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<p>表单控件（<code>input</code>、<code>select</code>、<code>textarea</code>）是用户输入数据的途径。一个表单（form）是表单控件的集合，用来组织相关的表单控件。</p>
<p>表单和表单控件提供验证服务，所以无效输入时]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="form" scheme="http://creeperyang.github.io/tags/form/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs控制器]]></title>
    <link href="http://creeperyang.github.io/2014/09/angular-controller/"/>
    <id>http://creeperyang.github.io/2014/09/angular-controller/</id>
    <published>2014-09-09T16:00:00.000Z</published>
    <updated>2015-07-02T15:15:29.000Z</updated>
    <content type="html"><![CDATA[<p>控制器可能是angular中最常接触的部分，前面几章都说到或者在用控制器，这章具体说一说。</p>
<h2 id="理解控制器">理解控制器</h2><p>在angular中，控制器是一个js构造函数<strong>（<code>constructor function</code>）</strong>，这个构造函数用来扩张<strong>Angular Scope</strong>(augment the Angular Scope，为scope添加属性)。</p>
<!--view-break-->
<p>当一个控制器通过<code>ng-controller</code>指令被附加（attach）到DOM，angular会用指定的控制器的<code>constructor function</code>实例化一个新的控制器对象（Controller object）。一个新的子scope会作为注入参数（<code>$scope</code>）传给构造函数。</p>
<p>我们用控制器来：</p>
<ul>
<li>设置<code>$scope</code>对象的初始状态;</li>
<li>为<code>$scope</code>对象添加行为。</li>
</ul>
<p>不要用控制器来：</p>
<ul>
<li>操作DOM——控制器只应该包含业务逻辑（business logic）。把任何展示逻辑（presentation logic）放入控制器会严重影响控制器的可测试性。angular的数据绑定可以应付绝大多数情况，并且指令封装了DOM操作。</li>
<li>格式化输入——用<a href="https://code.angularjs.org/1.3.0-rc.4/docs/guide/forms" target="_blank" rel="external">angular form controls</a>代替。</li>
<li>格式化输出——用过滤器代替。</li>
<li>在控制器之间共享代码或者状态——用服务代替。</li>
<li>控制其它组件的生命周期（例如，创建服务实例）。</li>
</ul>
<h2 id="设置$scope对象的初始状态">设置<code>$scope</code>对象的初始状态</h2><p>一般的，当你创建app时你需要设置<code>$scope</code>的初始状态。你通过为<code>$scope</code>对象添加属性来设置初始状态。这些属性包括<strong>view model</strong>(the model that will be presented by the view)。在控制器注册到的DOM的范围内，<code>$scope</code>的所有属性都是模板可访问的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">'myApp'</span>,[]);</span><br><span class="line"></span><br><span class="line">myApp.controller(<span class="string">'GreetingController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">  $scope.greeting = <span class="string">'Hola!'</span>;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>我们创建了<code>GreetingController</code>控制器，为其附加属性<code>greeting</code>。</p>
<p>我们创建模块<code>myApp</code>，用<code>controller</code>方法把控制器的构造函数添加到模块上。这样使构造函数不会暴露到全局。</p>
<h2 id="为scope对象添加行为">为scope对象添加行为</h2><p>为了与事件交互或者在视图中执行运算，必须为scope添加行为。我们通过为<code>$scope</code>对象添加方法来添加行为。这些方法可以在模板/视图中调用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"DoubleController"</span>&gt;</span></span><br><span class="line">Two times <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"num"</span>&gt;</span> equals &#123; &#123; double(num) &#125; &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">'myApp'</span>,[]);</span><br><span class="line"></span><br><span class="line">myApp.controller(<span class="string">'DoubleController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="variable">$scope</span>.double = <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>; &#125;;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如之前所说，附加到scope上的任意对象/基本类型（objects/primitives）都会成为模型属性，任何附加到scope的方法都可以在模板/视图中访问，通过表达式或<code>ng</code>事件处理指令（如<code>ng-click</code>）调用。</p>
<h2 id="正确使用控制器">正确使用控制器</h2><p>总体来说，一个控制器不要尝试做太多的事。一个控制器只应该包含一个单独的视图所需要的业务逻辑。</p>
<p>保持控制器瘦身的最通常做法是把不属于控制器的工作封装到服务，然后通过依赖注入来使用这些服务。具体的可以看看<a href="https://code.angularjs.org/1.3.0-rc.4/docs/guide/di" target="_blank" rel="external">Dependency Injection</a>和<a href="https://code.angularjs.org/1.3.0-rc.4/docs/guide/services" target="_blank" rel="external">Services</a>。</p>
<h2 id="Associating_Controllers_with_Angular_Scope_Objects">Associating Controllers with Angular Scope Objects</h2><p>你可以通过<code>ngController</code>指令和<code>$route</code>服务来显示地把控制器和scope联系起来。</p>
<h3 id="简单的”辣味“控制器例子">简单的”辣味“控制器例子</h3><p>为进一步描述控制器在angular中怎么工作的，让我们创建一个有以下组件的简单app：</p>
<ul>
<li>有2个buttons和一个简单的message的模板</li>
<li>一个模型，有叫spice的字符串</li>
<li>有2个函数设置spice值的控制器</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SpicyController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"chiliSpicy()"</span>&gt;</span>Chili<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"jalapenoSpicy()"</span>&gt;</span>Jalapeño<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>The food is &#123; &#123;spice&#125; &#125; spicy!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  <span class="keyword">var</span> myApp = angular.module(<span class="string">'spicyApp1'</span>, []);</span><br><span class="line"></span><br><span class="line">  myApp.controller(<span class="string">'SpicyController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$scope</span>.spice = <span class="string">'very'</span>;</span><br><span class="line">    <span class="variable">$scope</span>.chiliSpicy = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span>.spice = <span class="string">'chili'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable">$scope</span>.jalapenoSpicy = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span>.spice = <span class="string">'jalapeño'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由上面例子可知：</p>
<ul>
<li><code>ng-controller</code>指令（显然是）用来为模板创建一个scope的，并且这个scope会传给<code>SpicyController</code>控制器。</li>
<li><code>SpicyController</code>仅仅是个JS函数。作为可选的命名惯例，名字以大写字母开头，以”Controller”结尾。</li>
<li>为<code>$scope</code>赋值一个属性会创建/更新模型。Assigning a property to <code>$scope</code> creates or updates the model.</li>
<li>控制器的方法可以通过直接为scope赋值来创建，如<code>chiliSpicy</code>方法。</li>
<li>控制器的方法/属性在模板中可以访问。</li>
</ul>
<h3 id="”辣味“有参数的例子">”辣味“有参数的例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SpicyController"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"customSpice"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"spicy('chili')"</span>&gt;</span>Chili<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"spicy(customSpice)"</span>&gt;</span>Custom spice<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>The food is &#123; &#123;spice&#125; &#125; spicy!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">  <span class="keyword">var</span> myApp = angular.module(<span class="string">'spicyApp2'</span>, []);</span><br><span class="line"></span><br><span class="line">  myApp.controller(<span class="string">'SpicyController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">      <span class="variable">$scope</span>.customSpice = <span class="string">"wasabi"</span>;</span><br><span class="line">      <span class="variable">$scope</span>.spice = <span class="string">'very'</span>;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$scope</span>.spicy = <span class="function"><span class="keyword">function</span><span class="params">(spice)</span> </span>&#123;</span><br><span class="line">          <span class="variable">$scope</span>.spice = spice;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意一下，<code>ng-click=&quot;spicy(&#39;chili&#39;)&quot;</code>是直接传入字符串，<code>ng-click=&quot;spicy(customSpice)&quot;</code>传入模型属性。</p>
<h3 id="scope继承的例子">scope继承的例子</h3><p>在不同层级的DOM上附加不同级别的控制器很正常。因为<code>ng-controller</code>指令会创建新的子scope（new child scope），因而控制器有继承体系。低级别的控制器可以访问高级别的控制器的属性。具体可参考<a href="https://github.com/angular/angular.js/wiki/Understanding-Scopes" target="_blank" rel="external">Understanding Scopes</a>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"spicy"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MainController"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Good &#123; &#123;timeOfDay&#125; &#125;, &#123; &#123;name&#125; &#125;!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"ChildController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span>Good &#123; &#123;timeOfDay&#125; &#125;, &#123; &#123;name&#125; &#125;!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GrandChildController"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>Good &#123; &#123;timeOfDay&#125; &#125;, &#123; &#123;name&#125; &#125;!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">'scopeInheritance'</span>, []);</span><br><span class="line">myApp.controller(<span class="string">'MainController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="variable">$scope</span>.timeOfDay = <span class="string">'morning'</span>;</span><br><span class="line">  <span class="variable">$scope</span>.name = <span class="string">'Nikki'</span>;</span><br><span class="line">&#125;]);</span><br><span class="line">myApp.controller(<span class="string">'ChildController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="variable">$scope</span>.name = <span class="string">'Mattie'</span>;</span><br><span class="line">&#125;]);</span><br><span class="line">myApp.controller(<span class="string">'GrandChildController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="variable">$scope</span>.timeOfDay = <span class="string">'evening'</span>;</span><br><span class="line">  <span class="variable">$scope</span>.name = <span class="string">'Gingerbread Baby'</span>;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子scope中有同名属性则覆盖父scope的属性，没有则继承。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>控制器可能是angular中最常接触的部分，前面几章都说到或者在用控制器，这章具体说一说。</p>
<h2 id="理解控制器">理解控制器</h2><p>在angular中，控制器是一个js构造函数<strong>（<code>constructor function</]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="controller" scheme="http://creeperyang.github.io/tags/controller/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Classes and Modules]]></title>
    <link href="http://creeperyang.github.io/2014/08/classes-and-modules/"/>
    <id>http://creeperyang.github.io/2014/08/classes-and-modules/</id>
    <published>2014-08-24T16:00:00.000Z</published>
    <updated>2015-07-13T13:43:42.213Z</updated>
    <content type="html"><![CDATA[<p>JavaScript对象在第六章讲过了，之前我们只是把对象当作独一无二的属性的集合，每个对象都不同。但现在，我们要讲讲一类对象（a class of objects）共享某些属性。类的实例（instance）有自己的自由属性存储或定义自己的状态，也会有属性（方法）来定义自己的行为，这种行为通常是由类来定义并被所有实例共享。</p>
<p>在JavaScript中，类基于JavaScript的以原型为基础的继承机制。</p>
<!--view-break-->
<ul>
<li>如果两个对象继承自同一个原型，我们称这两个对象是同一个类的实例。</li>
<li>如果两个对象继承自同一个原型，这典型（但不是必然）表明两个对象被同一个构造函数创建和初始化。</li>
</ul>
<p>JavaScript的一个重要特征是动态可扩展（dynamically extendable）。</p>
<h2 id="类与原型（Classes_and_Prototypes）">类与原型（Classes and Prototypes）</h2><p>在JS中，类的所有实例对象都从同一个原型对象继承属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = inherit(range.methods);</span><br><span class="line">    r.from = from;</span><br><span class="line">    r.to = to;</span><br><span class="line">    <span class="comment">// Finally return the new object</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">range.methods = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to; &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到from、to是不可继承的，可继承的方法的都用到了from、to。注意一下<code>this</code>的使用：类的方法可以通过this来访问对象的属性。</p>
<h2 id="类与构造函数（Classes_and_Constructors）">类与构造函数（Classes and Constructors）</h2><p>上面是一种构造类的方法，但不常用，因为没有定义构造函数。</p>
<p>构造函数用来初始化对象。构造函数用new关键字调用。因为使用new调用构造函数会自动创建对象，所以构造函数要做的就是初始化对象。</p>
<p>构造函数调用的一个重要特征是新对象都用构造函数的prototype属性作为自己的prototype。所以这些新对象都是同一class的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.from = from;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to; &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// Create a range object</span></span><br><span class="line">r.includes(<span class="number">2</span>); <span class="comment">// =&gt; true: 2 is in the range</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log); <span class="comment">// Prints 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// Prints (1...3)</span></span><br><span class="line">r <span class="keyword">instanceof</span> Range <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数和类的标识（Constructors_and_Class_Identity）">构造函数和类的标识（Constructors and Class Identity）</h3><p>像我们看到的，原型对象是标识类的基础(fundamental)：两个对象从并且只从同一个原型对象继承属性时才是同一个类的实例对象。构造函数初始化对象的状态，但是不那么基础：两个构造函数可能原型属性指向同一个原型对象，那么这两个构造函数可以创建同一个类的实例对象。</p>
<p>但是，尽管构造函数不如原型重要，构造函数却是作为类的公共外观（public face）的。最明显的，构造函数的name常常用作类的name。另外，在测试对象是否是某个类的实例时，我们常用构造函数加<code>instanceof</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> Range</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>操作符实际上不会检查r是不是由Range构造函数来初始化的，而是检查r是不是继承了<code>Range.prototype</code>。但<code>instanceof</code>的语法强化了构造函数作为类的公共外观。</p>
<h3 id="构造函数属性（The_constructor_Property）">构造函数属性（The constructor Property）</h3><p>任意js函数可以作为构造函数，而构造函数必须有prototype属性。</p>
<p><strong>每个js函数F（除去 Function.bind()方法的返回值）自动有一个prototype属性，这个prototype属性的值有一个不可枚举的contructor属性。这个constructor属性的值就是这个函数对象F：</strong></p>
<blockquote>
<p>Therefore, every JavaScript function (except functions returned by the EC-<br>MAScript 5  Function.bind() method) automatically has a  prototype property. The value of this property is an object that has a single nonenumerable  constructor property. The value of the  constructor property is the function object:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// This is a function object.</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype; <span class="comment">// This is the prototype object associated with it.</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor; <span class="comment">// This is the function associated with the prototype.</span></span><br><span class="line">c === F <span class="comment">// =&gt; true: F.prototype.constructor==F for any function</span></span><br></pre></td></tr></table></figure>
<p>预定义的原型对象（原型对象有个constructor属性）的存在表明：新创建对象一般继承了constructor属性，这个constructor属性指向它们的构造函数。因此，构造函数可以作为类的公共标识，因为这个constructor属性指出了对象所属的类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F(); <span class="comment">// Create an object o of class F</span></span><br><span class="line">o.constructor === F <span class="comment">// =&gt; true: the constructor property specifies the class</span></span><br><span class="line">o <span class="keyword">instanceof</span> F <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>前面<code>Range</code>的例子中我们覆盖了预定义的<code>Range.prototype</code>，因此就没有constructor属性来，但我们可以显示添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line">    constructor: Range, <span class="comment">// Explicitly set the constructor back-reference</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在没添加前</span></span><br><span class="line">r.constructor  <span class="comment">// =&gt; function Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">//添加后</span></span><br><span class="line">r.constructor <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">//function Range(from, to) &#123;</span></span><br><span class="line"><span class="comment">//    this.from = from;</span></span><br><span class="line"><span class="comment">//    this.to = to;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>一点疑问：</p>
<p><code>F.prototype.constructor.prototype.constructor...</code>这种循环引用有没有性能问题？jQuery对象的定义好像也用到循环引用。</p>
<hr>
<h2 id="JS中Java风格的类（Java-Style_Classes_in_JavaScript）">JS中Java风格的类（Java-Style Classes in JavaScript）</h2><p>如果接触过Java之类的强类型面向对象语言，那么你可能习惯于想到四种类成员（class members）：</p>
<ul>
<li>实例字段（instance fields）：每个实例的属性或变量，保存独立实例对象的状态；</li>
<li>实例方法（Instance methods）：类的所有实例共享的方法，被每个实例调用；</li>
<li>类字段（Class fields）：属于类而不是某个实例的属性或变量；</li>
<li>类方法（Class methods）：属于类而不是某个实例的方法。</li>
</ul>
<p>JavaScript与Java的一个不同之处是：函数也是值（its functions are values），方法与字段没有明显区别。</p>
<p>除去这个不同之处，JavaScript可以模拟Java的四种类成员。在JS中，有3种不同的对象与类定义相关，而这3个对象的属性就可以模拟Java的四种类成员。</p>
<ul>
<li>构造器对象（Constructor object）。如上所说，JS中构造函数（也是对象）定义了类的名字。添加到构造函数上的属性相当于类属性和类方法。</li>
<li>原型对象（Prototype object）。原型对象的属性被所有实例继承，因此，如果原型对象的属性的值是函数时，就相当于实例方法。</li>
<li>实例对象（Instance object）。类的每个实例都是独立的对象，直接给实例定义的属性不会被其他实例共享，即实例字段。</li>
</ul>
<h2 id="增强类（Augmenting_Classes）">增强类（Augmenting Classes）</h2><p>JS的基于原型的继承机制是动态的：对象被创建后，原型变化也会影响这个对象。这意味着我们可以通过简单的添加新方法来增强类。</p>
<p>JS内置类也是开放的，你可以添加方法。</p>
<h2 id="类和类型（Classes_and_Types）">类和类型（Classes and Types）</h2><p>JS定义了一些类型（types）：null, undefined, boolean, number, string, function, object。</p>
<p><code>typeof</code>操作符可以区分这些类型。但是，把类当作对象的类型，并且以此区分对象可能更有用。JS内置对象（包括宿主对象）可以通过<code>Object.prototype.toString.call(obj).slice(8,-1);</code>来获取类名，但自定义对象则要通过本节介绍的一些方法来获取。</p>
<h3 id="instanceof操作符">instanceof操作符</h3><p><code>obj instanceof fun</code>，左边是对象，右边是构造函数，测试obj是否继承了fun的prototype。这种继承可以是间接的（多层继承）。</p>
<p>注意：构造函数是类的public identity，但原型才是最关键的。instanceof检查的是原型继承，而不是对象是否由该构造函数初始化。</p>
<p>如果你想测试原型链，可以用<code>prototypeObj.isPrototypeOf(obj)</code>。</p>
<p>这两个方法的缺点是无法知道对象的类名。而且在客户端（浏览器）中，多窗口和多框架子页面中web兼容性不佳。每个窗口和子页面都有单独的执行上下文，每个上下文都有独有的全局对象和一组构造函数：一个框架页面的数组instanceof另一个框架页面Array构造函数结果是false。</p>
<h3 id="构造函数属性（constructor_property）">构造函数属性（constructor property）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeAndValue</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// Null and undefined don't have constructors</span></span><br><span class="line">    <span class="keyword">switch</span>(x.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>: <span class="keyword">return</span> <span class="string">"Number: "</span> + x; <span class="comment">// Works for primitive types</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>: <span class="keyword">return</span> <span class="string">"String: '"</span> + x + <span class="string">"'"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>: <span class="keyword">return</span> <span class="string">"Date: "</span> + x; <span class="comment">// And for built-in types</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">RegExp</span>: <span class="keyword">return</span> <span class="string">"Regexp: "</span> + x;</span><br><span class="line">        <span class="keyword">case</span> Complex: <span class="keyword">return</span> <span class="string">"Complex: "</span> + x; <span class="comment">// And for user-defined types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的case后表达式都是函数，而typeof之类的返回值是字符串。</p>
<p>同instanceof一样，探测构造函数属性的方法没法在不同上下文下（不同框架页面、窗口）工作。另外，并非所有对象都有constructor属性，有的对象的constructor属性被覆盖，无法探测。</p>
<h3 id="构造函数名字（The_Constructor_Name）">构造函数名字（The Constructor Name）</h3><blockquote>
<p>The main problem with using the  instanceof operator or the  constructor property for determining the class of an object occurs when there are multiple execution contexts and thus multiple copies of the constructor functions. </p>
</blockquote>
<p>前面两种方法的一个重要缺陷是不同上下文时无法工作，所以我们可以尝试使用构造函数的名字而非构造函数本身。一些js实现（引擎）通过name属性让函数的名字可以被获取，而对一些没有name属性的JS实习来说，可以把函数转化为字符串，然后提取函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t, c, n; <span class="comment">// type, class, name</span></span><br><span class="line">    <span class="comment">// Special case for the null value:</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">    <span class="comment">// Another special case: NaN is the only value not equal to itself:</span></span><br><span class="line">    <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">"nan"</span>;</span><br><span class="line">    <span class="comment">// Use typeof for any value other than "object".</span></span><br><span class="line">    <span class="comment">// This identifies any primitive value and also functions.</span></span><br><span class="line">    <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">"object"</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="comment">// Return the class of the object unless it is "Object".</span></span><br><span class="line">    <span class="comment">// This will identify most native objects.</span></span><br><span class="line">    <span class="keyword">if</span> ((c = classof(o)) !== <span class="string">"Object"</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">// Return the object's constructor name, if it has one</span></span><br><span class="line">    <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">    (n = o.constructor.getName())) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// We can't determine a more specific type, so return "Object"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Object"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return the class of an object.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Return the name of a function (may be "") or null for nonfunctions</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*)\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数名字的方法仍然有问题，即不是所有对象都有constructor属性。另外，constructor属性的值可以是匿名函数。</p>
<h3 id="鸭式辨型（Duck-Typing）">鸭式辨型（Duck-Typing）</h3><p>上面的区分对象类型的方法都有问题（至少在客户端JS）。一个可替代方法是回避“what is the class of this object?”问题，转而回答 “what can this object do?”。</p>
<p>这种思考问题的方式与python和ruby很像，而Duck-Typing的称谓来源于这样一个表达：</p>
<blockquote>
<p>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function for duck-type checking</span></span><br><span class="line"><span class="comment">// Return true if o implements the methods specified by the remaining args.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quacks</span>(<span class="params">o <span class="comment">/*, ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123; <span class="comment">// for each argument after o</span></span><br><span class="line">        <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">typeof</span> arg) &#123; <span class="comment">// If arg is a:</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'string'</span>: <span class="comment">// string: check for a method with that name</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> o[arg] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'function'</span>: <span class="comment">// function: use the prototype object instead</span></span><br><span class="line">            <span class="comment">// If the argument is a function, we use its prototype object</span></span><br><span class="line">            arg = arg.prototype;</span><br><span class="line">            <span class="comment">// fall through to the next case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>: <span class="comment">// object: check for matching methods</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">in</span> arg) &#123; <span class="comment">// For each property of the object</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg[m] !== <span class="string">"function"</span>) <span class="keyword">continue</span>; <span class="comment">// skip non-methods</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> o[m] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we're still here, then o implements everything</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JS中的面向对象技术">JS中的面向对象技术</h2><p>略</p>
<h2 id="子类（subclasses）">子类（subclasses）</h2><p>在面向对象编程语言中，类B可以继承类A，即A为父类，B为子类。<strong>类B的实例继承了类A的所有实例方法。</strong>类B也会定义自己的实例方法，可能会重载类A的同名方法。如果类B的一个方法重载了类A的方法，并且这个方法有时想要调用类A的被重载方法，这就叫方法链（method chaining）。同理，类B的构造函数B()可能会要调用类A构造函数A()，这就叫构造函数链（constructor chaining）。子类还可以有子类，在这种层级关系中，有时定义虚类会比较有用。虚类就是定义了一个或多个未实现的方法，方法的实现由继承虚类的类来完成。</p>
<p>创建子类的关键就是正确地初始化原型对象。如果B继承自A，那么B.prototype必须是A.prototype的后裔。</p>
<h3 id="定义子类（Defining_a_Subclass）">定义子类（Defining a Subclass）</h3><p>JS中，对象继承（类的）原型对象的属性（通常是方法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = inherit(A.prototype); <span class="comment">// Subclass inherits from superclass</span></span><br><span class="line">B.prototype.constructor = B;<span class="comment">// Override the inherited constructor prop.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">// p must be a non-null object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="comment">// If Object.create() is defined...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p); <span class="comment">// then just use it.</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p; <span class="comment">// Otherwise do some more type checking</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// Define a dummy constructor function.</span></span><br><span class="line">    f.prototype = p; <span class="comment">// Set its prototype property to p.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// Use f() to create an "heir" of p.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple function for creating simple subclasses</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSubclass</span>(<span class="params">superclass, <span class="comment">// Constructor of the superclass</span></span><br><span class="line">                        constructor, <span class="comment">// The constructor for the new subclass</span></span><br><span class="line">                        methods,<span class="comment">// Instance methods: copied to prototype</span></span><br><span class="line">                        statics</span>)// <span class="title">Class</span> <span class="title">properties</span>: <span class="title">copied</span> <span class="title">to</span> <span class="title">constructor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// Set up the prototype object of the subclass</span></span><br><span class="line">    constructor.prototype = inherit(superclass.prototype);</span><br><span class="line">    constructor.prototype.constructor = constructor;</span><br><span class="line">    <span class="comment">// Copy the methods and statics as we would for a regular class</span></span><br><span class="line">    <span class="keyword">if</span> (methods) extend(constructor.prototype, methods);</span><br><span class="line">    <span class="keyword">if</span> (statics) extend(constructor, statics);</span><br><span class="line">    <span class="comment">// Return the class</span></span><br><span class="line">    <span class="keyword">return</span> constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和方法链（Constructor_and_Method_Chaining）">构造函数和方法链（Constructor  and Method Chaining）</h3><p>定义子类时，我们往往希望对父类的行为进行修改或扩充，而不是完全替换掉它们。为了做到这一点，构造函数或子类方法需要调用或链接到父类构造函数和父类方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NonNullSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Just chain to our superclass.</span></span><br><span class="line">    <span class="comment">// Invoke the superclass constructor as an ordinary function to initialize</span></span><br><span class="line">    <span class="comment">// the object that has been created by this constructor invocation.</span></span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make NonNullSet a subclass of Set:</span></span><br><span class="line">NonNullSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line">NonNullSet.prototype.constructor = NonNullSet;</span><br><span class="line"><span class="comment">// To exclude null and undefined, we only have to override the add() method</span></span><br><span class="line">NonNullSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check for null or undefined arguments</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't add null or undefined to a NonNullSet"</span>);</span><br><span class="line">    <span class="comment">// Chain to the superclass to perform the actual insertion</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="组合VS子类（Composition_Versus_Subclassing）">组合VS子类（Composition Versus Subclassing）</h3><p>一个广为人知的原则是“组合优于继承”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FilteredSet = <span class="built_in">Set</span>.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FilteredSet</span>(<span class="params">set, filter</span>) </span>&#123; <span class="comment">// The constructor</span></span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="comment">// The instance methods</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// If we have a filter, apply it</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.filter) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.filter(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"FilteredSet: value "</span> + v + <span class="string">" rejected by filter"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Now forward the add() method to this.set.add()</span></span><br><span class="line">            <span class="keyword">this</span>.set.add.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="类继承与虚类（Class_Hierarchies_and_Abstract_Classes）">类继承与虚类（Class Hierarchies and Abstract Classes）</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>wait...</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/tags/JavaScript/"/>
    
      <category term="class" scheme="http://creeperyang.github.io/tags/class/"/>
    
      <category term="module" scheme="http://creeperyang.github.io/tags/module/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/categories/frontend/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Object]]></title>
    <link href="http://creeperyang.github.io/2014/08/JavaScriptObject/"/>
    <id>http://creeperyang.github.io/2014/08/JavaScriptObject/</id>
    <published>2014-08-11T16:00:00.000Z</published>
    <updated>2015-07-13T13:43:30.333Z</updated>
    <content type="html"><![CDATA[<p>JavaScript对象是什么？</p>
<ul>
<li>js的基础数据类型（fundamental datatype）是对象（<em>object</em>）；</li>
<li>对象是无序的属性（<em>properties</em>）集合，每个属性是个key-value对；</li>
<li>但对象不仅仅是字符串到值的映射。除去有自己的属性集合，每个js对象都会从另一个对象继承属性，即原型（<em>prototype</em>）；</li>
<li>原型式继承（<em>prototypal inheritance</em>）是js的核心特性。</li>
</ul>
<p>JS对象是动态的，属性可以添加或删除。除去string、number、true/false、null、undefined，在js中其他值都是对象。</p>
<!--view-break-->
<blockquote>
<p>null is not an object, it is a primitive value. For example, you cannot add properties to it. Sometimes people wrongly assume that it is an object, because typeof null returns “object”. But that is actually a bug (that might even be fixed in ECMAScript 6).     <small><a href="http://stackoverflow.com/questions/801032/why-is-null-an-object-and-whats-the-difference-between-null-and-undefined/802371#802371" target="_blank" rel="external">参见stackoverflow</a></small></p>
</blockquote>
<p>null不是对象，是基础类型。不要被<code>typeof null;  // object</code>迷惑，这是js解释器的错误。 </p>
<p>property有name和value，name可以是任意字符串，包括空字符串（empty string），但一个对象不可能有相同的name。value可以任意js value，或者setter或/和getter方法（ecma5）。但除去name和value，对象还有3个相关的“属性特性”（<em>property attribute</em>）：</p>
<ul>
<li>writable attribute，指定value是否可以设置；</li>
<li>enumerable attribute，指定是否可以通过<code>for in</code>返回属性的name；</li>
<li>configurable attribute，指定是否可以删除该属性，或者属性的”属性特性”是否可以修改。</li>
</ul>
<p>除去属性，每个对象还拥有3个相关的“对象特性”（<em>object attribute</em>）：</p>
<ul>
<li>prototype，另一个对象的引用，本对象继承另一个对象的属性；</li>
<li>class，标识对象类型的字符串；</li>
<li>extensible flag（可扩展标记，ecma5），表明是否可以为对象添加新属性。</li>
</ul>
<p>最后，下面这些术语可以区分3类js对象和2类属性：</p>
<ul>
<li>内置对象（<em>native object</em>），ecma规范定义的对象或类，如Array等；</li>
<li>宿主对象（<em>host object</em>），js解释器嵌入的宿主环境（如web浏览器）所定义的，如DOM对象等；</li>
<li>自定义对象（<em>user-defined object</em>），运行js代码创建的对象。</li>
<li>自有属性（<em>own property</em>），直接在对象中定义的属性。</li>
<li>继承属性（<em>inherited property</em>），继承的属性。</li>
</ul>
<h2 id="创建对象">创建对象</h2><p>可以通过对象直接量（<em>object literals</em>）、new关键字、<code>Object.create()</code>（ecma5）方法创建对象。</p>
<h3 id="对象直接量">对象直接量</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   author: &#123;</span><br><span class="line">       firstname: <span class="string">"David"</span>,</span><br><span class="line">       lastname: <span class="string">"Yang"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"main title"</span>: <span class="string">"JavaScript"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： </p>
<ul>
<li>保留字作属性name时最好加引号，虽然ecma5与一部分3可以不加引号；</li>
<li>对象直接量最后一个属性后的逗号会忽略，但ie报错。</li>
</ul>
<p>对象直接量是一个表达式，这个表达式创建并初始化一个新的不同的对象。这意味着在loop中，对象直接量将创建很多新对象，并且每个对象的属性值可能也不同。</p>
<h3 id="new创建对象">new创建对象</h3><p>new运算符创建并初始化一个新对象。关键字new后面必须跟着一个函数调用，这个函数就叫构造函数（<em>constructor</em>）。构造函数用以初始化一个新创建的对象。</p>
<h3 id="原型">原型</h3><p>介绍第三种创建方法前，必须先解释一下原型。</p>
<p><strong>原型：</strong>每个js对象都有第二个js对象（可能是<code>null</code>，但很少见）与之相关，这个第二个js对象就是原型，并且第一个对象从原型继承属性。</p>
<blockquote>
<p>Every JavaScript object has a second JavaScript object (or  null ,<br>but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.</p>
</blockquote>
<ul>
<li>所有对象直接量的原型都一样，即Object.prototype;</li>
<li><strong>new创建的对象的原型就是构造函数的原型！</strong>所以：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// arr.prototype 就是 Array.prototype</span></span><br><span class="line">arr.__proto__ <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype === arr.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>var obj = Object.prtotype;</code>，obj就是很少的没有原型(<strong>原型是null</strong>)的对象之一：它不继承任何属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;x: <span class="number">1</span>&#125;; <span class="comment">// 对象直接量</span></span><br><span class="line">obj.__proto__ <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype === obj.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="第3种对象创建方法：Object-create()">第3种对象创建方法：Object.create()</h3><p>ecma5定义了<code>Object.create()</code>。这个方法创建一个新对象，方法的第一个参数就是新对象的原型。可选的第二个参数描述新对象的属性。</p>
<p><code>Object.create()</code>是静态方法，不是提供给某个对象调用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;x:<span class="number">1</span>, y:<span class="number">2</span>&#125;); <span class="comment">// o1 inherits properties x and y.</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">// o2 inherits no props or methods.</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype); <span class="comment">// o3 is like &#123;&#125; or new Object().</span></span><br></pre></td></tr></table></figure>
<p>一个简单的inherit方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">// p must be a non-null object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="comment">// If Object.create() is defined...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p); <span class="comment">// then just use it.</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p; <span class="comment">// Otherwise do some more type checking</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// Define a dummy constructor function.</span></span><br><span class="line">    f.prototype = p; <span class="comment">// Set its prototype property to p.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// Use f() to create an "heir" of p.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询和设置属性（Querying_and_Setting_Properties）">查询和设置属性（Querying and Setting Properties）</h2><p>js通过 点dot ( . )或方括号 square bracket ( [] ) 访问/设置属性。</p>
<p>点运算符后的标识不能是保留字，但ecma5放宽了限制。</p>
<p>方括号内的表达式必须是字符串，更严格讲，是可以转化为字符串的值。</p>
<h3 id="作为关联数组的对象（Objects_As_Associative_Arrays）">作为关联数组的对象（Objects As Associative Arrays）</h3><p>用方括号时，对象就类似于数组，只是下标是字符串而非数字。这种数组就叫关联数组。</p>
<p>对象作为关联数组使用时非常方便：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    addr += customer[<span class="string">"address"</span> + i] + <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<p>这是点操作符难以做到的。</p>
<h3 id="继承">继承</h3><p>属性查询时会顺着原型链查找，但设置属性时只会在对象上创建或修改属性，不会修改原型链。</p>
<h3 id="属性访问错误">属性访问错误</h3><p>查询一个不存在的属性会返回undefined，但对象不存在，查询其属性则报错。但可以这样来避免错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A concise and idiomatic alternative to get subtitle length or undefined</span></span><br><span class="line"><span class="keyword">var</span> len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure>
<p>有些属性是只读的，不能重新赋值；有些对象不允许新增属性，但设置这些属性的失败操作不会报错。ecma5的严格模式已经修复。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The prototype properties of built-in constructors are read-only.</span></span><br><span class="line"><span class="built_in">Object</span>.prototype = <span class="number">0</span>; <span class="comment">// Assignment fails silently; Object.prototype unchanged</span></span><br></pre></td></tr></table></figure>
<p>在这些场景下设置对象o的属性p会失败：</p>
<ul>
<li>o的属性p是只读的（有个例外：<code>defineProperty()</code>方法可以配置只读属性可以被设置）；</li>
<li>o有个继承的只读属性p：不可能通过设置同名属性来隐藏原型链上的只读属性；</li>
<li>o不可扩展。</li>
</ul>
<h2 id="删除属性">删除属性</h2><p><code>delete</code>操作符删除对象的属性。操作数必须是一个属性访问表达式。</p>
<p><code>delete</code>只能删除自有属性，不能删除继承属性。要删除继承的属性，必须从定义这个属性的原型对象上删除它。</p>
<p><code>delete</code>删除成功或没起作用时返回true；<code>delete</code>后面不是属性访问表达式时也返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x:<span class="number">1</span>&#125;; <span class="comment">// o has own property x and inherits property toString</span></span><br><span class="line"><span class="keyword">delete</span> o.x; <span class="comment">// Delete x, and return true</span></span><br><span class="line"><span class="keyword">delete</span> o.x; <span class="comment">// Do nothing (x doesn't exist), and return true</span></span><br><span class="line"><span class="keyword">delete</span> o.toString; <span class="comment">// Do nothing (toString isn't an own property), return true</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>; <span class="comment">// Nonsense, but evaluates to true</span></span><br></pre></td></tr></table></figure>
<p><em>configurable</em>设为false的属性不会被<code>delete</code>删除。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。严格模式中，删除不可配置属性会报TypeError，但ecma3并且是非严格模式下，仅仅是<code>return false；</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// Can't delete; property is non-configurable</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>; <span class="comment">// Declare a global variable</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x; <span class="comment">// return false; Can't delete this property</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// Declare a global function</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.f; <span class="comment">// Can't delete this property either</span></span><br></pre></td></tr></table></figure>
<p>非严格模式下，删除可配置属性时，可以省略对全局对象的引用，直接在<code>delete</code>操作符后跟上属性名即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span>; <span class="comment">// Create a configurable global property (no var)</span></span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// And delete it</span></span><br></pre></td></tr></table></figure>
<p>但在严格模式下，上述做法会报SyntaxError，必须：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> x; <span class="comment">// SyntaxError in strict mode</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>.x; <span class="comment">// This works</span></span><br></pre></td></tr></table></figure>
<h2 id="检测属性">检测属性</h2><p><code>in</code>运算符, <code>hasOwnProperty()</code>和<code>propertyIsEnumerable()</code>方法可以检测一个对象是否有某属性，或者简单的通过属性查询来完成。</p>
<p><code>in</code>运算符左侧是属性名（字符串），右侧是对象，如果对象的自有属性或继承属性包含这个属性的话，返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; x: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o; <span class="comment">// true: o has an own property "x"</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o; <span class="comment">// false: o doesn't have a property "y"</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;<span class="comment">// true: o inherits a toString property</span></span><br></pre></td></tr></table></figure>
<p><code>hasOwnProperty()</code>检测自有属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; x: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>); <span class="comment">// true: o has an own property x</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"y"</span>); <span class="comment">// false: o doesn't have a property "y"</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"toString"</span>); <span class="comment">// false: toString is an inherited property</span></span><br></pre></td></tr></table></figure>
<p><code>propertyIsEnumerable()</code>是<code>hasOwnProperty()</code>的增强版：只有是自有属性，并且属性的可枚举性（enumerable attribute）为true时才返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123; y: <span class="number">2</span> &#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">"x"</span>); <span class="comment">// true: o has an own enumerable property x</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"y"</span>); <span class="comment">// false: y is inherited, not own</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">"toString"</span>); <span class="comment">// false: not enumerable</span></span><br></pre></td></tr></table></figure>
<p>其实除去用<code>in</code>， <code>！==undefined</code>在大部分情况下可替代。但这种情况只能用in：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; x: <span class="literal">undefined</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举属性">枚举属性</h2><p>除去验证某个属性的存在，我们有时会列举对象所有属性，这常常也用<code>for/in</code>来做，但ecma5提供了2个便捷的替代方法。</p>
<ol>
<li><code>Object.keys()</code>， 返回 <strong>可枚举的自有属性</strong> 的name组成的数组。</li>
<li><code>Object.getOwnPropertyNames()</code>，类似<code>Object.keys()</code>，但返回自有属性而不止可枚举属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;x:<span class="number">1</span>&#125;);</span><br><span class="line">obj.y = <span class="number">2</span>;</span><br><span class="line">obj.toString() <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line">[<span class="string">"y"</span>]</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br><span class="line">[<span class="string">"y"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="属性Getter和Setter">属性Getter和Setter</h2><p>我们说过，属性是由name、value以及一组特性attribute构成的。</p>
<p>ecma5中，属性的value可以被1个或2个函数替代，这两个函数就是getter/setter。由getter/setter定义的属性常被称作“访问器属性”（“accessor property”），以区别于“数据属性”（“data property”），数据属性只有一个简单的值。</p>
<p>当程序查询“访问器属性”时，js调用getter方法（不传参），方法返回值就是属性值。js调用setter时，赋值表达式右侧的值就作为参数传入setter。忽略setter的返回值。</p>
<p>“访问器属性”没有<em>writable</em>特性：</p>
<ul>
<li>同时有setter/getter，读/写属性;</li>
<li>只有setter，只写属性（“数据属性”不可能做到这一点），读取时得到undefined;</li>
<li>只有getter，只读属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="comment">// An ordinary data property</span></span><br><span class="line">    data_prop: value,</span><br><span class="line">    <span class="comment">// An accessor property defined as a pair of functions</span></span><br><span class="line">    <span class="comment">// 访问器属性一般成对定义</span></span><br><span class="line">    get accessor_prop() &#123; <span class="comment">/* function body here */</span> &#125;,</span><br><span class="line">    set accessor_prop(value) &#123; <span class="comment">/* function body here */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p= &#123;</span><br><span class="line">    <span class="comment">// x and y are regular read-write data properties.</span></span><br><span class="line">    x:<span class="number">1.0</span>,</span><br><span class="line">    y:<span class="number">1.0</span>,</span><br><span class="line">    <span class="comment">// r is a read-write accessor property with getter and setter.</span></span><br><span class="line">    <span class="comment">// Don't forget to put a comma after accessor methods.</span></span><br><span class="line">    get r() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x*<span class="keyword">this</span>.x + <span class="keyword">this</span>.y*<span class="keyword">this</span>.y); &#125;,</span><br><span class="line">    set r(newvalue) &#123;</span><br><span class="line">        <span class="keyword">var</span> oldvalue = <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x*<span class="keyword">this</span>.x + <span class="keyword">this</span>.y*<span class="keyword">this</span>.y);</span><br><span class="line">        <span class="keyword">var</span> ratio = newvalue/oldvalue;</span><br><span class="line">        <span class="keyword">this</span>.x *= ratio;</span><br><span class="line">        <span class="keyword">this</span>.y *= ratio;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// theta is a read-only accessor property with getter only.</span></span><br><span class="line">    get theta() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.y, <span class="keyword">this</span>.x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“访问器属性”和“数据属性”一样可以被继承。</p>
<h2 id="属性特性（Property_Attributes）">属性特性（Property Attributes）</h2><p>属性特性指定属性是否可写、可枚举、可配置。ecma3无法设置这些，ecma5提供了查询和设置这些特性的api。这些api对类库来说很重要，因为：</p>
<ul>
<li>允许为原型对象添加方法，并让方法不可枚举，跟内置的方法一样;</li>
<li>允许锁住对象，定义不可更改、删除的属性。</li>
</ul>
<p>我们把“访问器属性”的setter/getter看作特性，按这个逻辑，“数据属性”的值也可以看作特性。因此，可以说一个属性有一个名字和4个特性：value、writable、enumerable、configurable。</p>
<blockquote>
<p>we can say that a property has a name and four attributes. The four attributes of a data property are value, writable, enumerable, and configurable.</p>
</blockquote>
<p>为了实现属性特性的查询和设置，ecma5定义了一个叫“属性描述符”（property descriptor）的对象来代表那4个特性。描述符对象的属性和它们所描述的属性特性是同名的，因此：</p>
<ul>
<li>“数据属性”的描述符对象有value、writable、enumerable、configurable等4个属性；</li>
<li>“访问器属性”的描述符对象则用getter/setter代替value和writable。</li>
</ul>
<p>writable、enumerable、configurable都是布尔值。getter/setter是函数。</p>
<p>通过<code>Object.getOwnPropertyDescriptor()</code>可以对指定对象获取指定属性的描述符对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns &#123;value: 1, writable:true, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;x:<span class="number">1</span>&#125;, <span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This object has accessor properties that return random numbers.</span></span><br><span class="line"><span class="keyword">var</span> random = &#123;</span><br><span class="line">    get octet() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">256</span>); &#125;,</span><br><span class="line">    get uint16() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">65536</span>); &#125;,</span><br><span class="line">    get int16() &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">65536</span>)-<span class="number">32768</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Returns &#123; get: /*func*/, set:undefined, enumerable:true, configurable:true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(random, <span class="string">"octet"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"x"</span>); <span class="comment">// undefined, no such prop</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;&#125;, <span class="string">"toString"</span>); <span class="comment">// undefined, inherited</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptor()</code>只能获取自有属性的描述符对象，对继承的属性，要遍历原型链（<code>Object.getPrototypeOf()</code>）。</p>
<p>要设置属性特性，用<code>Object.defineProperty()</code>，传入参数：要修改的对象、属性、描述符对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// Start with no properties at all</span></span><br><span class="line"><span class="comment">// Add a nonenumerable data property x with value 1.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; value : <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">// Check that the property is there but is nonenumerable</span></span><br><span class="line">o.x; <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o) <span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now modify the property x so that it is read-only</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; writable: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// Try to change the value of the property</span></span><br><span class="line">o.x = <span class="number">2</span>; <span class="comment">// Fails silently or throws TypeError in strict mode</span></span><br><span class="line">o.x <span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The property is still configurable, so we can change its value like this:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; value: <span class="number">2</span> &#125;);</span><br><span class="line">o.x <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// Now change x from a data property to an accessor property</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123; get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; &#125;);</span><br><span class="line">o.x <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure>
<p><code>Object.defineProperty()</code>创建/修改自有属性，不能修改继承的属性。</p>
<p><code>Object.defineProperties()</code>同时创建或修改多个属性,返回修改过的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">    x: &#123; value: <span class="number">1</span>, writable: <span class="literal">true</span>, enumerable:<span class="literal">true</span>, configurable:<span class="literal">true</span> &#125;,</span><br><span class="line">    y: &#123; value: <span class="number">1</span>, writable: <span class="literal">true</span>, enumerable:<span class="literal">true</span>, configurable:<span class="literal">true</span> &#125;,</span><br><span class="line">    r: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.x*<span class="keyword">this</span>.x + <span class="keyword">this</span>.y*<span class="keyword">this</span>.y) &#125;,</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对不允许修改/创建的属性用上述2个方法，会报错：TypeError。一般说，writable特性控制着value特性，configurable特性控制着其它特性，但这不是绝对的，具体规则如下：</p>
<ul>
<li>如果对象是不可扩展的，则可以编辑已有属性，但不能添加新属性；</li>
<li>如果“访问器属性”是不可配置的，则不能修改getter和setter方法，也不能转为“数据属性”；</li>
<li>如果“数据属性”是不可配置的，则不能将它转换为“访问器属性”；</li>
<li>如果“数据属性”是不可配置的，则不能将它的writable从false修改为true，但可以从true修改为false；</li>
<li>如果“数据属性”是不可配置且不可写的，则不能修改它的值。</li>
</ul>
<h3 id="getter和setter的老式API">getter和setter的老式API</h3><p>在ecma5标准被采纳之前，一些浏览器已经可以支持set和get。具体略。</p>
<h2 id="对象特性/属性（Object_Attributes）">对象特性/属性（Object Attributes）</h2><p>每个对象都有<code>prototype、class、extensible</code>3个特性。</p>
<h3 id="prototype属性">prototype属性</h3><p>prototype特性指定对象从哪个对象继承属性。这个属性非常重要，因此我们常简称为“对象o的原型”，而非“对象o的原型属性”。</p>
<p>原型属性是对象创建之初就设置好的。复述一下之前提到的：</p>
<ul>
<li>对象字面量的原型是Object.prototype;</li>
<li>new创建的对象的原型是构造函数的原型；</li>
<li>Object.create()用第一个参数（可以是null）作为原型。</li>
</ul>
<p>在ecma5中，<code>Object.getPrototypeOf()</code>可以查询对象的原型，而ecma3没有对应的方法。但我们可以通过<code>o.constructor.prototype</code>来检测对象o的原型。<strong>通过new创建的对象，通常继承一个constructor属性，该属性指代创建这个对象的构造函数。</strong>如上所说，构造函数的prototype就是新建对象的prototype。这一点在之后会详细解释，并且同时会解释为什么用这种方法检测原型不太可靠。</p>
<p>对象直接量或者通过<code>Object.create()</code>创建的对象有一个constructor属性，该属性值为<code>Object()</code>构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123;x:<span class="number">1</span>&#125;);</span><br><span class="line">o.constructor <span class="comment">// =&gt;function Object() &#123; [native code] &#125;</span></span><br><span class="line">o.constructor.prototype  <span class="comment">// =&gt; Object &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此，对对象直接量而言，<code>constructor.prototype</code>指向正确的原型，但对<code>Object.create()</code>创建的对象而言，指向原型常常不正确。</p>
<p>要想检测一个对象是否是另一个对象的原型（或处于原型链中），用<code>isPrototypeOf()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;x:<span class="number">1</span>&#125;; <span class="comment">// Define a prototype object.</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p); <span class="comment">// Create an object with that prototype.</span></span><br><span class="line">p.isPrototypeOf(o) <span class="comment">// =&gt; true: o inherits from p</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o) <span class="comment">// =&gt; true: p inherits from Object.prototype</span></span><br></pre></td></tr></table></figure>
<h3 id="class特性（The_class_Attribute）">class特性（The class Attribute）</h3><p>一个对象的class特性是一个字符串，代表对象的类型信息。</p>
<p>ecma3，ecma5都没有提供设置这个特性的方法，并且只有一个间接的技术去查询它。默认的<code>toString</code>方法（继承自Object.prototype）返回这种形式的字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object class]</span><br></pre></td></tr></table></figure>
<p>可以查询类特性的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>classof</code>函数可以传入任何类型的参数。number、string、bool都可以正确得出class，null和undefined也特殊对待了。内建的对象也可以正常得出同名class，如Date、Array等。另外，宿主对象一般也可以得出有意义的class名（取决于实现方式）。但是，自定义的对象、对象字面量、Object.create创建的对象都只能得出<code>Object</code>。所以对自定义的类来说，无法通过class来区分。</p>
<h3 id="可扩展特性（The_extensible_Attribute）">可扩展特性（The extensible Attribute）</h3><p>一个对象的可扩展特性指定该对象是否能够新加属性。</p>
<p>在ecma3中，显然所有内建对象和用户自定义对象都可以扩展，宿主对象的可扩展性是由JS引擎定义的。ecma5默认所有内建对象和用户自定义对象是可扩展的，除非你转换成不可扩展；而宿主对象的可扩展性仍然是引擎定义。</p>
<p>ecma5定义了函数来查询和设置对象的扩展性：</p>
<ul>
<li>Object.isExtensible()，是否可扩展；</li>
<li>Object.preventExtensions()，转换对象为不可扩展。<strong>已经转换为不可扩展的对象不能再转换为可扩展。</strong>另外，不可扩展一般指定的是本对象，你可以为它的原型对象添加属性。</li>
<li>Object.seal()，除了使对象不可扩展，还使对象自有属性不可配置，即新属性无法添加，已有属性不能添加，已有属性不能删除或配置。没有方法去unseal一个对象，可以用<code>Object.isSealed()</code>去检测对象是否seal。</li>
<li>Object.freeze()更严格，相比seal，它使所有属性只读（但getter/setter不受影响）。记住，freeze同样只对本对象起作用，不影响原型。</li>
</ul>
<p>extensible特性的意义是能够“lock down”对象，使对象维持一个某一状态，不会被外部修改。</p>
<h2 id="序列化对象（Serializing_Objects）">序列化对象（Serializing Objects）</h2><p>对象的序列化（serialization）就是把对象转化为字符串的过程（之后可以从字符串恢复）。</p>
<p>ecma5使用<code>JSON.stringify()``JSON.parse()</code>来序列化和反序列化对象。</p>
<p>JSON：JavaScript Object Notation，语法和js对象字面量很相似。</p>
<p>JSON语法是JS语法的子集，它不能代表所有的js值。如RegExp、Error对象、undefined值不能序列化和反序列化。</p>
<p><strong>JSON只序列化可枚举的自有属性！</strong></p>
<h2 id="对象方法（Object_Methods）">对象方法（Object Methods）</h2><p>如之前所说，所有的对象（除去创建时明显没有原型的）都从<code>Object.prototype</code>继承属性。</p>
<h3 id="toString()">toString()</h3><p><code>toString()</code>方法无参数，返回字符串，某种程度上代表调用这个方法的对象的值。</p>
<h3 id="toLocaleString()">toLocaleString()</h3><p>返回本地化的字符串。</p>
<h3 id="toJSON()">toJSON()</h3><p>Object.prototype实际上没有定义这个方法，但对需要序列化的对象来说，JSON.stringify()会查找toJSON方法，存在则调用。</p>
<h3 id="valueOf()">valueOf()</h3><p>valueOf()和toString()很像，但往往但js需要将对象转换成某种原始值而不是字符串时会调用它。默认的valueOf什么都没做，但<code>Date</code>做了处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.valueOf() <span class="comment">// =&gt;1408867947768</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>wait...</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="http://creeperyang.github.io/tags/Object/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="JavaScript" scheme="http://creeperyang.github.io/categories/frontend/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Visual Formatting Model]]></title>
    <link href="http://creeperyang.github.io/2014/08/VisualFormattingModel/"/>
    <id>http://creeperyang.github.io/2014/08/VisualFormattingModel/</id>
    <published>2014-08-06T16:00:00.000Z</published>
    <updated>2015-07-13T13:43:17.725Z</updated>
    <content type="html"><![CDATA[<p>声明：</p>
<p>本文参考<a href="http://topic.csdn.net/u/20100719/17/ff203b89-135e-46cf-8fce-705f16e37beb.html?006156676166584196" target="_blank" rel="external">http://topic.csdn.net/u/20100719/17/ff203b89-135e-46cf-8fce-705f16e37beb.html?006156676166584196</a></p>
<p>定义以下术语：</p>
<ol>
<li>visual formatting model： 可视化格式模型，下文中简称模型。</li>
<li>media： 媒介，CSS中的重要概念，即展示页面的介质，最常见的是screen（显示器），其它还有纸媒介等待。</li>
<li>user agent： 用户代理，即浏览器。</li>
<li>dom tree： 文档树，下文中简称树。</li>
<li>box model： 盒模型。</li>
<li>positioning scheme： 定位体系。</li>
<li>containing blocks： 包含块，元素生成box，该box就是子元素的包含块。</li>
<li>block-level elements, block box: 块级元素，块框</li>
<li>inline-level elements, inline box： 行内级别元素，行内框</li>
<li>inline-level box： 行内级别框</li>
<li><p>replaced element: 其内容不受CSS视觉格式化模型控制的元素,比如image,嵌入的文档(iframe之类)或者applet,叫做替换元素。</p>
<p>比如,img元素的内容通常会被其src属性指定的图像替换掉。替换元素通常有其固有的尺寸:一个固有的宽度,一个固有的高度和一个固有的比率。比如一幅位图有固有用绝对单位指定的宽度和高度,从而也有固有的宽高比率。另一方面,其他文档也可能没有固有的尺寸,比如一个空白的html文档。</p>
<p>CSS渲染模型不考虑替换元素内容的渲染。这些替换元素的展现独立于CSS。object,video,textarea,input也是替换元素,audio和canvas在某些特定情形下为替换元素。使用CSS的content属性插入的对象是匿名替换元素。</p>
</li>
<li><p>non-replaced element: 非替换元素，替换元素之外的所有其他元素都是非替换元素,由CSS的视觉格式化模型负责非替换元素的渲染。</p>
</li>
</ol>
<!--view-break-->
<h2 id="Introduction_to_the_visual_formatting_model">Introduction to the visual formatting model</h2><p>本章及下章描述了可视化格式模型：浏览器怎么为可视媒介处理文档树？</p>
<p>在模型中，根据盒模型，树中每个元素生成0个或多个盒子。这些盒子的布局受以下因素影响：</p>
<ol>
<li><p>box尺寸和类型。</p>
<p>类型特指<code>display</code>特性决定的元素类型，如<code>div</code>是块级元素，<code>span</code>是行内元素。</p>
</li>
<li><p>定位体系。</p>
<p>元素在布局时，根据3种定位体系定位。分别是，常规流、浮动和绝对定位。</p>
</li>
<li><p>文档树中元素之间的关系。</p>
<p>比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块的影响。</p>
</li>
<li><p>外部信息。</p>
<p> 比如，可视窗口的大小，我们有时候会做页面自适应窗口大小的功能，就是因为，窗口大小对布局有影响。再如，图片的固有尺寸，会影响行内替换元素的尺寸，进而影响整个布局。</p>
</li>
</ol>
<p>模型没有定义格式的所有细节，所以在没有定义的方面（比如letter-spacing）各浏览器可能表现有差异。</p>
<h3 id="The_viewport">The viewport</h3><p>视口，显示屏上的窗口或其它显示区域。视口尺寸大小改变时，浏览器会改变文档的布局。比如，有些值是依赖于视口大小的，<code>div</code> width的auto值，等等。</p>
<p>当视口的尺寸小于文档渲染的画布（也就是页面）的大小时，浏览器应该提供滚动机制。每个画布最多有一个视口。但是，浏览器可以同时渲染多个画布。也就是说，浏览器可以打开多个页面，但是每个页面最多只有一个视口。</p>
<h3 id="Containing_blocks">Containing blocks</h3><p>在CSS2.1中，很多box的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，就被称作是包含块(containing block)。一般来说，(元素)生成的box会扮演它子孙元素包含块的角色；我们称之为：一个元素的box为它的子孙节点创建了包含块。</p>
<p>包含块是一个相对的概念。“一个box的包含块”，指的是“该box所存在的那个包含块”，并不是它建造的包含块。</p>
<p>每个box相对于它的包含块都有一个位置，但是它不会被包含块限制；它可以溢出(包含块)。</p>
<h2 id="Controlling_box_generation(控制框的生成)">Controlling box generation(控制框的生成)</h2><p>我们经常用到块元素、行内元素的概念，那么，到底什么是块元素，什么是行内元素，它们有什么特点，怎么形成的，有什么作用呢？什么是块框，什么又是行内框呢？</p>
<h3 id="块级元素和块框">块级元素和块框</h3><p>块级元素是源文档中那些在视觉上被格式化为块的元素（如：段落）。下面这些’display’属性的取值会产生块级元素：’block’，’list-item’，以及’table’。</p>
<p>块级框是参与block formatting context的框。每个块级元素会生成一个主块级框（principal block-level box），这个主块级框包含后代框、生成的内容，并且也是涉及所有定位体系的框。一些块级元素会生成主块级框之外的框（additional boxes），比如<code>&#39;list-item&#39;</code>元素。这些额外的框相对于主块级框来定位。</p>
<p>除去table框和替换元素，其它块级框也是块级容器框（a block container box），它可能仅包含块级框，或者仅包含行内框（会创建inline formatting context）。不是所有的块级容器框都是块级框：非替换的行内框和非替换的表格单元格（cell）是块级容器框但不是块级框。块级框简称块框。</p>
<p>三个术语 <em>[块级框block-level box、块级容器框block container box、块框block box]</em> 在不严格区分时都可以缩写为 <em>块（block）</em>。</p>
<h4 id="匿名块框">匿名块框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// example 1</span><br><span class="line"><span class="tag">&lt;<span class="title">DIV</span>&gt;</span></span><br><span class="line">  Some text</span><br><span class="line">  <span class="tag">&lt;<span class="title">P</span>&gt;</span>More text</span><br><span class="line"><span class="tag">&lt;/<span class="title">DIV</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（并假定DIV和P都设置了 ‘display: block’），DIV看来包含行内内容和块内容。为了使格式化简单一些，我们假定有一个匿名块框围绕在”Some text”周围。</p>
<p><img src="http://www.w3.org/TR/CSS21/images/anon-block.png" alt="示意图"></p>
<p>换句话说，如果块级容器框（上面的DIV）内有一个块级框（上面P），那么我们将强制它（DIV）内部只有块级框（这里是插入匿名块框）。</p>
<p>当一个行内框(inline box)包含一个块级框时，这个行内框（和与它处于同一行框内的祖先行内框）会围绕着块级框被截断。行内框会被分成两个行框（line boxes），块级框（们）两边各一个。断点之前和之后的行框(line box)会被封装到匿名的块框里，并且，原来的块级框会成为这些匿名块框的兄弟框。当这样的行内框受到相对定位的影响时，相对定位也会影响它内部的块框。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/1r1x0gp0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>上述代码中，P元素包含匿名文本区块 C1，后跟块级元素SPAN，最后是匿名文本区块C2。最终生成的框(boxes)是代表BODY的块框，包含着围绕C1的匿名块框，SPAN的块框，和另一个围绕C2的匿名块框。</p>
<p>匿名框的属性(properties)从包含它的非匿名框那里继承而来（比如，例1中，匿名框会继承包含它的DIV的属性）。非继承属性会使用初始值。比如，匿名框会从DIV继承字体，但是margin会是0 。</p>
<p>匿名框不会影响元素的原有属性设置。如例2中P设置了border，产生匿名框后，C1、C2还是被红色的边框包围。</p>
<p>子框计算百分比时匿名父块框被忽略，即：最近的非匿名祖先框被用来代替匿名框计算百分比。比如，一个在DIV里的匿名块框的子元素需要知道它的包含块的高度以用来处理百分比高度。它将使用DIV创建的包含块的高度，而非匿名块框。</p>
<h3 id="行内级别元素和行内框">行内级别元素和行内框</h3><p>行内元素是源文档中那些不形成新的内容块的元素；内容在行内分布（如，段落内着重的文本，行内图形等等）。某些’display’特性的值形成行内元素：’inline’，’inline-table’，’inline-table’。行内级别元素生成行内框（inline box）。行内框参与 inline formatting context。</p>
<p>行内框肯定是行内级别（inline-level），并且它的内容参与它包含的inline formatting context。非替换元素（并且display: inline）生成行内框。不是行内框的行内级别框（Inline-level boxes），比如行内级别的替换元素、inline-block元素、inline-table元素被称为原子行内级别框，因为它们作为单一不透明框参与inline formatting context。</p>
<h4 id="匿名行内框">匿名行内框</h4><p>任何被块容器元素直接包含（不是行内元素）的文字都被当作匿名行内元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Some <span class="tag">&lt;<span class="title">em</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="title">em</span>&gt;</span> text<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>P元素生成一个块控制框，其内还有几个行内框。”emphasized”的框是一个行内元素（<code>&lt;em&gt;</code>）产生的行内框，而其它的框（”Some”和”text”）是块级元素（P）产生的行内框。后者就称为匿名行内控制框，因为它们没有与之相关的行内元素，所以，这些框被叫做匿名行内框。</p>
<p>这样的行内框从其父块框那里继承可以继承的属性。非继承属性取它们的初始值。例子中，初始匿名框的颜色继承自P，而背景是透明的。</p>
<p>空格内容会根据 ‘white-space’ 属性被压缩，不会创建任何匿名行内框。</p>
<p>匿名行内框和匿名块框可以被统称为匿名框。</p>
<p>在格式化 table 时，会形成更多的匿名框。</p>
<h3 id="插入框（run-in_box）">插入框（run-in box）</h3><p>插入框的表现如下：</p>
<ol>
<li>如果插入框包含一个块框，那么插入框会成为一个块框；</li>
<li>如果一个块框（不是浮动，也不是绝对定位）跟随在一个插入的控制框之后，则该插入框成为该块框的第一个行内框。</li>
<li>否则，该插入框成为一个块框。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">H3</span> <span class="attribute">style</span>=<span class="value">"display:run-in"</span>&gt;</span>A run-in heading.<span class="tag">&lt;/<span class="title">H3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">P</span>&gt;</span>And a paragraph of text that follows it.</span><br></pre></td></tr></table></figure>
<p>若浏览器支持run-in，则显示如下：</p>
<p><strong>A run-in heading.</strong> And a paragraph of text that follows it.</p>
<p>尽管，从视觉看，它成为后面块框的一部分，插入元素的属性仍然继承自源树中它的父元素。</p>
<h3 id="display_属性">display 属性</h3><p>display可取值：</p>
<p>inline | block | list-item | run-in | compact | marker |table | inline-table | table-row-group | table-header-group |table-footer-group | table-row | table-column-group | table-column |table-cell | table-caption | none | inherit|</p>
<table>
<thead>
<tr>
<th>display</th>
<th>样式</th>
</tr>
</thead>
<tbody>
<tr>
<td>block</td>
<td>该值使一个元素生成一个块框。</td>
</tr>
<tr>
<td>inline-block</td>
<td>该值使一个元素生成一个块框，自身在文档流中像一个行内元素，跟替换元素相似。元素的内部按照块框格式化，自身按照一个行内替换元素格式化。</td>
</tr>
<tr>
<td>inline</td>
<td>该值使一个元素生成一个或多个行内框。</td>
</tr>
<tr>
<td>list-item</td>
<td>该值使一个元素（如HTML中的LI）生成一个原始块框和一个列表项行内框。</td>
</tr>
<tr>
<td>none</td>
<td>该值使一个元素在格式化结构中不显示（换言之，该元素对布局没有影响）。子孙元素也不产生任何框；该行为不能由设置子孙元素的 ‘display’ 属性而被覆盖。请注意 ‘none’ 的显示特性并不生成一个不可见的框；它根本不生成框。CSS包含了机制使一个元素能够在格式化结构中生成框而影响格式化，但本身不可见( visible 特性)。</td>
</tr>
<tr>
<td>run-in</td>
<td>根据上下文，这些值要么生成块框，要么生成行内框。</td>
</tr>
</tbody>
</table>
<h2 id="定位体系（Positioning_schemes）">定位体系（Positioning schemes）</h2><p>CSS2.1中，一个框(box，就是元素形成的方块等)可以根据三种定位体系布局。</p>
<ol>
<li><p>常规流(Normal flow)</p>
<p> 包括块框的块格式化（block formatting），行级框的行格式化（inline formatting），块框与行框的相对定位。</p>
</li>
<li><p>浮动(Floats)</p>
<p> 在浮动模型中，一个框(box)首先根据常规流布局，再将它从流中取出并尽可能地向左或向右偏移。内容可以沿浮动区的侧面排列。</p>
</li>
<li><p>绝对定位(Absolute positioning)</p>
<p> 在绝对定位模型中，一个框(box)整个地从常规流向中脱离（它对后续的兄弟元素没有影响），并根据它的包含块来分配其位置。</p>
</li>
</ol>
<blockquote>
<p>An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow. The flow of an element A is the set consisting of A and all in-flow elements whose nearest out-of-flow ancestor is A.</p>
</blockquote>
<p>元素如果浮动、绝对定位或者是根元素，那么它被称为out-of-flow; 元素如果不是out-of-flow，那么它就是in-flow。</p>
<h3 id="选择定位方案：”position”属性">选择定位方案：”position”属性</h3><table>
<thead>
<tr>
<th>position 取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>static</td>
<td>该框(box)是一个常规框，布局根据常规流，’left’ 、’right’、’bottom’和 ‘top’属性不适用。如果 ‘position’没有设置，默认值也是’static’。</td>
</tr>
<tr>
<td>relative</td>
<td>框的位置根据常规流计算（被称为常规流中的位置）。然后框相对于它的常规位置而偏移。如果框 B 是相对定位的，其后框的定位计算并不考虑B的偏移。 table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, 和 table-caption 元素的’position:relative’ 效果没有被定义。</td>
</tr>
<tr>
<td>absolute</td>
<td>框的位置（可能还有它的尺寸）是由’left’，’right’，’top’和’bottom’特性决定。这些特性指定了框相对于它包含块的偏移量。绝对定位的框从常规流向中脱离。这意味着它们对其后的兄弟元素的定位没有影响。另外，尽管绝对定位框有外边距(margin)，它们不会和其它任何 margin 发生折叠（Collapsing margins）。</td>
</tr>
<tr>
<td>fixed</td>
<td>框位置的计算根据’absolute’模型，不过框要额外地根据一些参考而得到固定。跟绝对定位一样，fixed定位元素的margin不会和任何其他margin发生margin折叠。应用于手持终端、投影设备、屏幕、TTY、电视媒体类型时，框相对于 viewport 固定，滚动时不移动。应用于打印媒介类型时，框被渲染于每一页，并相对于页框固定，就好象是通过viewport查看该页一样（例如，打印预览）。对于其他的媒介类型，表现没有被定义。</td>
</tr>
</tbody>
</table>
<p>对根元素的 position，用户端(UA)可以视为“static”。</p>
<h3 id="框偏移:_‘top’，’right’，’bottom’，’left’">框偏移: ‘top’，’right’，’bottom’，’left’</h3><p>如果一个元素的’position’特性值不是’static’，该元素被称为定位元素。定位的元素生成定位框，其定位基于四个特性：’top’，’right’，’bottom’，’left’。</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>值：</td>
<td>这四个特性的值可以是：`<length></length></td>
<td><percentage></percentage></td>
<td>auto</td>
<td>inherit` 之一。</td>
</tr>
<tr>
<td>初始值：</td>
<td>‘auto’</td>
</tr>
<tr>
<td>适用于：</td>
<td>定位的元素，即 position特性的值为非 ‘static’的值。</td>
</tr>
<tr>
<td>可否继承：</td>
<td>否</td>
</tr>
<tr>
<td>百分比值：</td>
<td>百分比值基于包含块的高度(top, bottom)或者宽度(left, right)</td>
</tr>
<tr>
<td>计算值：</td>
<td>对于position:relative 参见相对定位(后续会介绍)；对于position:static 取值auto；其他情况，如果值为长度，取相应的绝对长度，如果标值为百分比，取指定的值，否则，取auto。</td>
</tr>
<tr>
<td>定位作用的具体位置：</td>
<td>对于绝对定位元素(absolutely positioned)的框，这四个特性的值表示，元素的外边界(margin边界)相对于 包含块 的边界的位移。而对于相对定位元素(relatively positioned)的框，偏移量相对于它自己的相应的边界。比如，top是相对于它的顶边界，right相对于右边界。</td>
</tr>
</tbody>
</table>
<p>4个值有以下含义：</p>
<ul>
<li>length: 偏移量是距离参照边的固定值。</li>
<li>percentage: 偏移量是包含块宽度（对于’left’和’right’）或高度（对于’top’ 和’bottom’）的百分比。对于’top’和’bottom’，如果包含块的高度没有显式指定（即它取决于内容的高度），百分比值将解释为’auto’。</li>
<li>auto: 该值的效果取决于与之相关的属性中的哪一个也设置了’auto’。</li>
</ul>
<h2 id="常规流（Normal_flow）">常规流（Normal flow）</h2><p>在常规流中的框（boxes，元素形成的矩形区域），都属于一个格式化的上下文中，可能是块的，也可能是行内的，但不可能同时是行内的又是块的。块框参与块格式化上下文。行内框参与行内格式化上下文。</p>
<h3 id="块格式化上下文(Block_formatting_contexts)">块格式化上下文(Block formatting contexts)</h3><p>浮动元素，绝对定位元素，inline-blocks，table-cells，table-captions，以及 ‘overflow’不是 ‘visible’的元素，会创建新的block formatting context。</p>
<h2 id="Containing_blocks详细">Containing blocks详细</h2><p>上面说道，一个元素box的定位和尺寸，有时候会跟某一矩形框有关，这个矩形框，就被称作元素的包含块。而元素会为它的子孙元素创建包含块，那么，是不是说，元素的包含块就是它的父元素呢？答案是否定的，这是一个误区。也正因为如此，才会专门来说明它。</p>
<p><strong>一个元素包含块的确定，跟元素自身和它的祖先元素的样式等有关系。</strong></p>
<h3 id="根元素的包含块">根元素的包含块</h3><p>根元素，就是处于文档树最顶端的元素，它没有父节点。</p>
<p>根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。</p>
<ul>
<li>在(X)HTML中，根元素是html元素（尽管有的浏览器会不正确地使用body元素）。</li>
<li>初始包含块的direction属性与根元素相同。</li>
</ul>
<h3 id="“static”和”relative”定位的元素">“static”和”relative”定位的元素</h3><p>对于其它元素：如果该元素的定位（position）为 “relative” （相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的box创建。</p>
<p>元素如果未声明”position”特性 ，那么就会采用”position”的默认值 ”static”。所以，一般元素都是静态定位的。</p>
<h3 id="“position:fixed”_定位的元素">“position:fixed” 定位的元素</h3><p>如果元素是固定定位 (“position:fixed”) 元素，那么它的包含块是当前可视窗口。</p>
<h3 id="“position:_absolute”_定位的元素">“position: absolute” 定位的元素</h3><p>如果元素是绝对定位（”position: absolute”）元素，包含块由离它最近的position属性为 “absolute”、”relative” 或者 “fixed” 的祖先元素创建。</p>
<p>…</p>
<p>…</p>
<p>…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>wait...</p>]]>
    
    </summary>
    
      <category term="Box model" scheme="http://creeperyang.github.io/tags/Box-model/"/>
    
      <category term="CSS" scheme="http://creeperyang.github.io/tags/CSS/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
      <category term="CSS" scheme="http://creeperyang.github.io/categories/frontend/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs Filter]]></title>
    <link href="http://creeperyang.github.io/2014/07/angular-filter/"/>
    <id>http://creeperyang.github.io/2014/07/angular-filter/</id>
    <published>2014-07-24T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/frontend/2014/07/angular-data-binding/">前一章</a>在scope上定义了一个reverse函数，可以倒序输出字符串——这就是过滤器（filter）的雏形。</p>
<p><strong>定义：</strong>filter格式化一个表达式的值，以展现给用户。filter可以在模板、控制器、指令或服务中使用，并且容易定义你自己的过滤器。</p>
<!--view-break-->
<p>filter的底层API是<code>filterProvider</code>。</p>
<h3 id="在视图/模板中用过滤器">在视图/模板中用过滤器</h3><p>filter的一般用法如<code>{ { expression | filter } }</code>。要应用多个filter时，直接链式使用即可。另外，filter是可以传入参数的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">&#123; &#123; expression | filter1 | filter2 | ... &#125; &#125;</span><br><span class="line"><span class="comment">// 如果要传入参数</span></span><br><span class="line">&#123; &#123; expression | filter:argument1:argument2:... &#125; &#125;</span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line">&#123; &#123; <span class="number">1234</span> | number:<span class="number">2</span> &#125; &#125; <span class="comment">// ==&gt;1,234.00</span></span><br></pre></td></tr></table></figure>
<h3 id="在控制器、服务和指令中使用过滤器">在控制器、服务和指令中使用过滤器</h3><p>在控制器、服务和指令中使用过滤器需要注入依赖，具体语法是<code>&lt;filterName&gt;Filter</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'oneModule'</span>, []).</span><br><span class="line">controller(<span class="string">'oneController'</span>, [<span class="string">'nameFilter'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">nameFilter</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filteredValue = nameFilter(inputValue, filterArg1, filterArg2, ...);</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>参数<code>nameFilter</code>就是过滤函数，它的参数和之前一样。</p>
<h3 id="自定义过滤器">自定义过滤器</h3><p>定义过滤器很简单：把新的过滤器工厂（filter factory）注册到模块上即可。内部实现上angular使用了<code>filterProvider</code>。</p>
<p>这个工厂函数必须返回一个过滤函数，过滤函数的第一个参数是输入值，接下来的参数是过滤参数。</p>
<p>过滤函数必须是纯函数（pure function），即是无状态的和幂等的（stateless and idempotent）。angular依赖这些属性并且仅仅在输入改变时调用过滤器。</p>
<p>一个自定义过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"><span class="comment">// 注册reverse过滤器到模块myApp上</span></span><br><span class="line"><span class="comment">// 工厂函数返回一个过滤函数，工厂函数可以 注入依赖</span></span><br><span class="line">myApp.filter(<span class="string">'reverse'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//can inject dependency</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用： &lt;h1&gt;&#123; &#123; data.message | reverse &#125; &#125;&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="有状态的过滤器（Stateful_filters）">有状态的过滤器（Stateful filters）</h3><p>强烈不建议写有状态的过滤器。</p>
<p>略。</p>
<h3 id="ngFilter">ngFilter</h3><p><code>ngFilter</code>会选取数组的一个子集并作为新数组返回。</p>
<p><code>ngFilter</code>是angular的内置指令，但功能正如描述的——filter，可以作为搜索器使用（如下例）。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/81jL8bu3/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="内置的过滤器">内置的过滤器</h3><p>angular内置了一些常用过滤器，你可以方便使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"actor in avengers cast | orderBy:'name'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"actor in avengers cast | limitTo:5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"actor in avengers cast | filter:search | orderBy:'name'  | limitTo: 5 "</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="/frontend/2014/07/angular-data-binding/">前一章</a>在scope上定义了一个reverse函数，可以倒序输出字符串——这就是过滤器（filter）的雏形。</p>
<p><strong>定义：</strong>f]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="filter" scheme="http://creeperyang.github.io/tags/filter/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs的数据绑定]]></title>
    <link href="http://creeperyang.github.io/2014/07/angular-data-binding/"/>
    <id>http://creeperyang.github.io/2014/07/angular-data-binding/</id>
    <published>2014-07-19T16:00:00.000Z</published>
    <updated>2015-07-02T15:14:37.000Z</updated>
    <content type="html"><![CDATA[<p>前面两章内容比较多，但看完前两章，对angular应该会有一个比较全面的了解。这章开始，会对angular中的每个部分做细致讲解，首先从数据绑定讲起。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-app</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">         &#123; &#123; "john" + "lindquist" &#125; &#125;</span><br><span class="line">         <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">'data.msg'</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123; data.msg &#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--view-break-->
<p>上面是很简单的例子，关注两点：</p>
<ul>
<li>属性<code>ng-app</code>指定当前元素以及内部的一切都属于这个app;</li>
<li>绑定可以用<code>ng-bind</code>指令或双大括号来表示。但注意，为了防止liquid误解析，在大括号之间插入了空格（前面几章包括后面都会如此）。</li>
</ul>
<h3 id="通过控制器获取数据">通过控制器获取数据</h3><p>把上面例子中的<code>ng-model</code>去除，用控制器来提供数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-app</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstCtrl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123;data.message + " world"&#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"&#123; &#123;data.message&#125; &#125;"</span>&gt;</span></span><br><span class="line">      Wrap me in a foundation component</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstCtrl</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line">  $scope.data = &#123;message: <span class="string">"Hello"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示了数据绑定时从控制器获取数据。正如之前所说，控制器是一个上下文，表达式可以通过它访问模型。</p>
<h3 id="点（dot）在数据绑定中的重要性">点（dot）在数据绑定中的重要性</h3><p>了解了数据绑定和控制器之后，我们讨论第一个重难点：dot的作用。</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/g85a63u4/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>代码很简单，效果很明显：</p>
<ul>
<li>有点时，在3个输入框的输入彼此影响;</li>
<li>无点时，三个<code>msg</code>彼此独立不影响。</li>
</ul>
<p>解释一下原因：scope默认是继承父scope的，<code>FirstCtrl</code>和<code>SecondCtrl</code>都继承了父scope（此处是<code>rootScope</code>，并且由于第一个<code>data.message</code>而创建了data属性），而<code>FirstCtrl</code>和<code>SecondCtrl</code>没有覆盖父scope的任何属性：</p>
<ul>
<li>有点时，<code>FirstCtrl</code>和<code>SecondCtrl</code>都仅仅继承（引用）<code>rootScope</code>的<code>data</code>属性，那么<code>data.msg</code>的<code>data</code>都指向同一个<code>data</code>对象。</li>
<li>无点时，<code>FirstCtrl</code>、<code>SecondCtrl</code>和<code>rootScope</code>都会创建各自的<code>msg</code>属性，所以有三个互不影响的<code>msg</code>属性。</li>
</ul>
<p>其实可以打开控制台看看输出，那么一切明晰：</p>
<p><code>FirstCtrl</code>、<code>SecondCtrl</code>有<code>msg</code>属性而没有<code>data</code>属性！<strong>证明有点时，scope会查寻自己及父scope（链）上的对应模型;没有点时，则首先创建自己的属性。</strong></p>
<h3 id="通过服务在控制器之间共享数据">通过服务在控制器之间共享数据</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-app</span>=<span class="value">"myApp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"data.message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123; data.message &#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstCtrl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"data.message"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123; data.message &#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondCtrl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"data.message"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123; data.message &#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">    <span class="keyword">var</span> myApp = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line">    myApp.factory(<span class="string">'Data'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; message: <span class="string">"I'm data from a service"</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FirstCtrl</span><span class="params">(<span class="variable">$scope</span>, Data)</span> </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span>.data = Data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SecondCtrl</span><span class="params">(<span class="variable">$scope</span>, Data)</span> </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span>.data = Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意2点：</p>
<ul>
<li>服务是单例的，所以<code>FirstCtrl</code>和<code>SecondCtrl</code>的data指向同一个对象，互相影响;</li>
<li><code>rootScope</code>的data不再影响<code>FirstCtrl</code>和<code>SecondCtrl</code>，这是因为<code>FirstCtrl</code>和<code>SecondCtrl</code>定义了自己的<code>data</code>属性（覆盖）。</li>
</ul>
<h3 id="在scope上定义方法">在scope上定义方法</h3><p>表达式中可以调用方法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondCtrl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"data.message"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>&#123; &#123; reversedMessage(data.message) &#125; &#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="php"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SecondCtrl</span><span class="params">(<span class="variable">$scope</span>, Data)</span> </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span>.data = Data;</span><br><span class="line">        <span class="variable">$scope</span>.reversedMessage = <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> message.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两章内容比较多，但看完前两章，对angular应该会有一个比较全面的了解。这章开始，会对angular中的每个部分做细致讲解，首先从数据绑定讲起。</p>
<figure class="highlight html"><table><tr><td class="gutt]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="controller" scheme="http://creeperyang.github.io/tags/controller/"/>
    
      <category term="data binding" scheme="http://creeperyang.github.io/tags/data-binding/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJs入门（启动、表达式和数据绑定）]]></title>
    <link href="http://creeperyang.github.io/2014/07/angular-bootstrap/"/>
    <id>http://creeperyang.github.io/2014/07/angular-bootstrap/</id>
    <published>2014-07-11T16:00:00.000Z</published>
    <updated>2015-07-02T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>angular的一个闪光点是你只需要对框架有个很少的了解就能顺利跑起Demo了。这很好，你可以边学边实际做，毕竟自学最重要的一点是动手，而不是<code>biabiabia</code>看些文档或视频就好。</p>
<p>首先，看怎么启动最简单的Angular应用。</p>
<!--view-break-->
<h2 id="启动angular">启动angular</h2><p>angular可以自动启动或手动启动。</p>
<h3 id="Angular_&lt;script&gt;_Tag">Angular <code>&lt;script&gt;</code> Tag</h3><p>下面是官方推荐的启动方式，可以自动初始化。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">ng-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"angular.js"</span> /&gt;</span><span class="apache"></span><br><span class="line">  <span class="tag">&lt;/body&gt;</span></span><br><span class="line"><span class="tag">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>把<code>script</code>标签放在页面底部，这样可以防止html加载不被angular加载阻塞。</li>
<li>把<code>ng-app</code>放在app的根上，一般是<code>&lt;html&gt;</code>标签，这样angular可以自动初始化app。</li>
</ul>
<h3 id="自动初始化(Automatic_Initialization)">自动初始化(Automatic Initialization)</h3><p>angular会自动初始化，一般在<code>DOMContentLoaded</code>事件发生时或者<code>document.readyState</code>是<code>complete</code>时且<code>angular.js</code>脚本被执行。这时，angular会寻找<code>ng-app</code>指令，<code>ng-app</code>就指定了app root。一旦<code>ng-app</code>被找到，angular会做以下事情：</p>
<ul>
<li>加载与指令相关的模块（module）;</li>
<li>创建注入器;</li>
<li>编译dom，把<code>ng-app</code>指令当作编译开始的根元素。</li>
</ul>
<h3 id="手动初始化(Manual_Initialization)">手动初始化(Manual Initialization)</h3><p>如果你希望控制初始化过程，你可以手动初始化。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  Hello &#123; &#123;greetMe&#125; &#125;!</span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://code.angularjs.org/snapshot/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="comment">// 先定义app 模块</span></span><br><span class="line">    angular.module(<span class="string">'myApp'</span>, [])</span><br><span class="line">      .controller(<span class="string">'MyController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">        $scope.greetMe = <span class="string">'World'</span>;</span><br><span class="line">      &#125;]);</span><br><span class="line">    <span class="comment">// 载入app模块，应用启动后不能在添加controllers, services, directives等等</span></span><br><span class="line">    angular.element(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      angular.bootstrap(<span class="built_in">document</span>, [<span class="string">'myApp'</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表达式(Angular_Expressions)">表达式(Angular Expressions)</h2><p>angular表达式是类js代码（<code>JavaScript-like code snippets</code>），经常放在绑定中，如<code>{ { expression } }</code>。</p>
<p>一些合法的例子：</p>
<ul>
<li><code>1+2</code></li>
<li><code>a+b</code></li>
<li><code>user.name</code></li>
<li><code>items[index]</code></li>
</ul>
<h3 id="angular表达式与js代码的区别">angular表达式与js代码的区别</h3><ul>
<li><strong>context</strong>：js代码一般以<code>window</code>为全局对象执行，angular表达式一般是<code>scope</code>;</li>
<li><strong>Forgiving</strong>：js中，计算<code>undefined</code>的属性时报错，angular会宽容forgiving to <code>undefined</code> and <code>null</code>;</li>
<li><strong>No Control Flow Statements</strong>：没有流程控制，如条件、循环或例外（exceptions）;</li>
<li><strong>Filters</strong>：可以使用过滤器格式化表达式的输出。</li>
</ul>
<h4 id="Context">Context</h4><p>angular不使用<code>eval()</code>来计算表达式。angular使用<code>$parse</code>服务来处理表达式。</p>
<p>angular表达式无法访问全局变量如<code>window</code>, <code>document</code>或者<code>location</code>。这种严格是故意的，可以防止意外改变全局变量——这常常会导致bug。</p>
<p>可以在函数中使用<code>$window</code>和<code>$location</code>服务代替。</p>
<h4 id="Forgiving">Forgiving</h4><p>表达式执行会forgiving to undefined and null。在js中，如果a不是对象，执行<code>a.b.c</code>会抛出异常。</p>
<p>表达式执行通常是为了数据绑定，形式如<code>{ { a.b.c } }</code>，a是<code>undefined</code>（通常是等待服务器response，然后a会被定义）则会抛出异常，这很不好。如果没有Forgiving，我们可能不得不写这样的表达式：<code>{ { ((a||{}).b||{}).c } }</code>。</p>
<h4 id="No_Control_Flow_Statements">No Control Flow Statements</h4><p>除了三元操作符（<code>a ? b : c</code>），angular表达式中不允许任何流程控制语句。</p>
<p>有这种限制的原因是angular的哲学：应用逻辑应该在控制器中，而不是在视图中。</p>
<h4 id="Filter">Filter</h4><p>看例子：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/creeper/vbd4qdwm/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>这里面<code>{ {clickEvent | json} }</code>就有过滤器json。</p>
<p>注意：</p>
<ul>
<li>我们怎么把<code>$event</code>传给<code>clickMe</code>函数的。</li>
<li><code>$event</code>在第一处为什么不能显示？因为<code>$event</code>不在绑定的<code>scope</code>范围内。</li>
</ul>
<h2 id="数据绑定（Data_Binding）">数据绑定（Data Binding）</h2><p>Angular的数据绑定就是<strong>模型（model）</strong>和<strong>视图组件（view components）</strong>之间的数据的自动同步。</p>
<p>angular实现数据绑定的方式让你把模型看作app中唯一真相的来源（lets you treat the model as the single-source-of-truth in your application）。视图是模型的投影，模型的任何改动将会影响视图，反之亦然。</p>
<h3 id="经典模板系统中的数据绑定">经典模板系统中的数据绑定</h3><p><img src="https://docs.angularjs.org/img/One_Way_Data_Binding.png" alt="例图"></p>
<p>绝大多数模板系统的数据绑定都是单向的：它们把模型组件和模板合并得出视图。一旦合并后，视图或模型某一方的改动都不会影响到另一方，即开发者必须自己写代码去保持两者同步。</p>
<h3 id="angular模板的数据绑定">angular模板的数据绑定</h3><p><img src="https://docs.angularjs.org/img/Two_Way_Data_Binding.png" alt="例图"></p>
<p>angular模板不同。</p>
<p>首先，angular模板（未编译的html，包括任意额外的标签或指令）是在浏览器端编译。</p>
<p>编译阶段生成活动视图（live view）：视图上的任何改变将反馈给模型，模型的任何改变将传播到视图。模型是app状态的唯一可信来源（single-source-of-truth），这大大简化了编程模型——你可以把视图当作模型的一个投影。</p>
<p>因为视图只是模型的投影，控制器就和视图完全分离了。这又使测试更容易了，因为测试的控制器与视图分离，不依赖DOM/浏览器环境。</p>
<h3 id="一次性绑定（One-time_binding）">一次性绑定（One-time binding）</h3><p>以<code>::</code>开头的表达式是一次性绑定，即一旦有稳定值（不是<code>undefined</code>）后不再重新计算。</p>
<h4 id="为什么要有这种特性？">为什么要有这种特性？</h4><p>One-time binding的主要目的是提供这样一种绑定：一旦有稳定值后绑定可以注销并释放资源。简而言之，为提高性能而设计。</p>
<h4 id="值稳定算法（Value_stabilization_algorithm）">值稳定算法（Value stabilization algorithm）</h4><p>在每个digest循环结束时，One-time binding会获取表达式的值，只要这个值不是<code>undefined</code>。具体算法如下：</p>
<ol>
<li>给定的表达式以<code>::</code>开头，当一次digest循环开始，expression is dirty-checked store the value as V；</li>
<li>如果V不是undefined，标记表达式结果是stable，计划一个任务（schedule a task ），在一次digest循环结束时去注销监视（deregister the watch）；</li>
<li>像正常情况一样处理digest循环；</li>
<li>当digest循环结束，并且所有值都稳定了，处理watch deregistration tasks队列。对每个注销任务而言，检查值是否计算后仍然不为undefined，如果不是undefined，注销监视，否则转第一步。</li>
</ol>
<h4 id="怎么利用一次性绑定">怎么利用一次性绑定</h4><p>当插入文字或属性时，如果这个表达式的值一旦确定就不再改变，那么这就适合用一次性绑定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">name</span>=<span class="value">"attr: &#123; &#123;::color&#125; &#125;"</span>&gt;</span>text: &#123; &#123;::name&#125; &#125;<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="nimrod"></span><br><span class="line">someModule.directive('someDirective', function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    scope: &#123;</span><br><span class="line">      name: '=',</span><br><span class="line">      color: '@'</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">template</span>: '&#123; &#123;name&#125; &#125;: &#123; &#123;color&#125; &#125;'</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>这篇是「angular学习系列」第2篇，讲了怎么启动angular应用，讲了基本的表达式和数据绑定。但文章仍然侧重介绍，对angular官网guide的翻译居多，下一篇会侧重数据绑定来讲，结合更多代码，阐述实际应用中的重点。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>angular的一个闪光点是你只需要对框架有个很少的了解就能顺利跑起Demo了。这很好，你可以边学边实际做，毕竟自学最重要的一点是动手，而不是<code>biabiabia</code>看些文档或视频就好。</p>
<p>首先，看怎么启动最简单的Angular应用。</p>]]>
    </summary>
    
      <category term="AngularJs" scheme="http://creeperyang.github.io/tags/AngularJs/"/>
    
      <category term="frontend" scheme="http://creeperyang.github.io/categories/frontend/"/>
    
  </entry>
  
</feed>