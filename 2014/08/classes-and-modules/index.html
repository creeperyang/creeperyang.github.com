<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0" />
    <meta name="author" content="Creeper Yang" />
    <meta name="description" content="Creeper's blog, focus on JavaScript/Html(5)/Css(3)" />
    <meta name="keywords" content="Creeper Yang,blog,JavaScript,html5,development">
    
    <title>JavaScript Classes and Modules | Creeper&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <link rel="alternative" href="/atom.xml" title="Creeper&#39;s Blog" type="application/atom+xml">
    
    
        <link rel="icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/assets/styles/material.min.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/app.css" type="text/css">
</head>
    <body class='mdl-color--grey-100 mdl-color-text--grey-800 mdl-base'>
        <div class="mdl-layout post-page article-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100">
    <div class="article-ribbon">
        <a class="btn-back mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" href="javascript:history.back();">
            <i class="material-icons">arrow_back</i>
        </a>
    </div>
    <main class="article-main mdl-layout__content">
        <div class="cus-grid section--center mdl-grid">
<div class="mdl-cell mdl-cell--12-col">
    <div class="article-content mdl-color--white mdl-shadow--4dp mdl-color-text--grey-800">
        <div class="article-body">
            <div class="article-crumbs mdl-color-text--grey-500">
                
    
    <span class="category-item">Posts</span> &gt; <span class="category-item">frontend</span> &gt; <span class="category-item">JavaScript</span> &gt; <span class="category-item">JavaScript Classes and Modules</span> 

            </div>
            <h3>JavaScript Classes and Modules</h3>
            <p>JavaScript对象在第六章讲过了，之前我们只是把对象当作独一无二的属性的集合，每个对象都不同。但现在，我们要讲讲一类对象（a class of objects）共享某些属性。类的实例（instance）有自己的自由属性存储或定义自己的状态，也会有属性（方法）来定义自己的行为，这种行为通常是由类来定义并被所有实例共享。</p>
<p>在JavaScript中，类基于JavaScript的以原型为基础的继承机制。</p>
<!--view-break-->
<ul>
<li>如果两个对象继承自同一个原型，我们称这两个对象是同一个类的实例。</li>
<li>如果两个对象继承自同一个原型，这典型（但不是必然）表明两个对象被同一个构造函数创建和初始化。</li>
</ul>
<p>JavaScript的一个重要特征是动态可扩展（dynamically extendable）。</p>
<h2 id="类与原型（Classes_and_Prototypes）">类与原型（Classes and Prototypes）</h2><p>在JS中，类的所有实例对象都从同一个原型对象继承属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = inherit(range.methods);</span><br><span class="line">    r.from = from;</span><br><span class="line">    r.to = to;</span><br><span class="line">    <span class="comment">// Finally return the new object</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">range.methods = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to; &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到from、to是不可继承的，可继承的方法的都用到了from、to。注意一下<code>this</code>的使用：类的方法可以通过this来访问对象的属性。</p>
<h2 id="类与构造函数（Classes_and_Constructors）">类与构造函数（Classes and Constructors）</h2><p>上面是一种构造类的方法，但不常用，因为没有定义构造函数。</p>
<p>构造函数用来初始化对象。构造函数用new关键字调用。因为使用new调用构造函数会自动创建对象，所以构造函数要做的就是初始化对象。</p>
<p>构造函数调用的一个重要特征是新对象都用构造函数的prototype属性作为自己的prototype。所以这些新对象都是同一class的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.from = from;</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to; &#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// Create a range object</span></span><br><span class="line">r.includes(<span class="number">2</span>); <span class="comment">// =&gt; true: 2 is in the range</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log); <span class="comment">// Prints 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// Prints (1...3)</span></span><br><span class="line">r <span class="keyword">instanceof</span> Range <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数和类的标识（Constructors_and_Class_Identity）">构造函数和类的标识（Constructors and Class Identity）</h3><p>像我们看到的，原型对象是标识类的基础(fundamental)：两个对象从并且只从同一个原型对象继承属性时才是同一个类的实例对象。构造函数初始化对象的状态，但是不那么基础：两个构造函数可能原型属性指向同一个原型对象，那么这两个构造函数可以创建同一个类的实例对象。</p>
<p>但是，尽管构造函数不如原型重要，构造函数却是作为类的公共外观（public face）的。最明显的，构造函数的name常常用作类的name。另外，在测试对象是否是某个类的实例时，我们常用构造函数加<code>instanceof</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> Range</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>操作符实际上不会检查r是不是由Range构造函数来初始化的，而是检查r是不是继承了<code>Range.prototype</code>。但<code>instanceof</code>的语法强化了构造函数作为类的公共外观。</p>
<h3 id="构造函数属性（The_constructor_Property）">构造函数属性（The constructor Property）</h3><p>任意js函数可以作为构造函数，而构造函数必须有prototype属性。</p>
<p><strong>每个js函数F（除去 Function.bind()方法的返回值）自动有一个prototype属性，这个prototype属性的值有一个不可枚举的contructor属性。这个constructor属性的值就是这个函数对象F：</strong></p>
<blockquote>
<p>Therefore, every JavaScript function (except functions returned by the EC-<br>MAScript 5  Function.bind() method) automatically has a  prototype property. The value of this property is an object that has a single nonenumerable  constructor property. The value of the  constructor property is the function object:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// This is a function object.</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype; <span class="comment">// This is the prototype object associated with it.</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor; <span class="comment">// This is the function associated with the prototype.</span></span><br><span class="line">c === F <span class="comment">// =&gt; true: F.prototype.constructor==F for any function</span></span><br></pre></td></tr></table></figure>
<p>预定义的原型对象（原型对象有个constructor属性）的存在表明：新创建对象一般继承了constructor属性，这个constructor属性指向它们的构造函数。因此，构造函数可以作为类的公共标识，因为这个constructor属性指出了对象所属的类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F(); <span class="comment">// Create an object o of class F</span></span><br><span class="line">o.constructor === F <span class="comment">// =&gt; true: the constructor property specifies the class</span></span><br><span class="line">o <span class="keyword">instanceof</span> F <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>前面<code>Range</code>的例子中我们覆盖了预定义的<code>Range.prototype</code>，因此就没有constructor属性来，但我们可以显示添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line">    constructor: Range, <span class="comment">// Explicitly set the constructor back-reference</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在没添加前</span></span><br><span class="line">r.constructor  <span class="comment">// =&gt; function Object() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">//添加后</span></span><br><span class="line">r.constructor <span class="comment">// =&gt;</span></span><br><span class="line"><span class="comment">//function Range(from, to) &#123;</span></span><br><span class="line"><span class="comment">//    this.from = from;</span></span><br><span class="line"><span class="comment">//    this.to = to;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>一点疑问：</p>
<p><code>F.prototype.constructor.prototype.constructor...</code>这种循环引用有没有性能问题？jQuery对象的定义好像也用到循环引用。</p>
<hr>
<h2 id="JS中Java风格的类（Java-Style_Classes_in_JavaScript）">JS中Java风格的类（Java-Style Classes in JavaScript）</h2><p>如果接触过Java之类的强类型面向对象语言，那么你可能习惯于想到四种类成员（class members）：</p>
<ul>
<li>实例字段（instance fields）：每个实例的属性或变量，保存独立实例对象的状态；</li>
<li>实例方法（Instance methods）：类的所有实例共享的方法，被每个实例调用；</li>
<li>类字段（Class fields）：属于类而不是某个实例的属性或变量；</li>
<li>类方法（Class methods）：属于类而不是某个实例的方法。</li>
</ul>
<p>JavaScript与Java的一个不同之处是：函数也是值（its functions are values），方法与字段没有明显区别。</p>
<p>除去这个不同之处，JavaScript可以模拟Java的四种类成员。在JS中，有3种不同的对象与类定义相关，而这3个对象的属性就可以模拟Java的四种类成员。</p>
<ul>
<li>构造器对象（Constructor object）。如上所说，JS中构造函数（也是对象）定义了类的名字。添加到构造函数上的属性相当于类属性和类方法。</li>
<li>原型对象（Prototype object）。原型对象的属性被所有实例继承，因此，如果原型对象的属性的值是函数时，就相当于实例方法。</li>
<li>实例对象（Instance object）。类的每个实例都是独立的对象，直接给实例定义的属性不会被其他实例共享，即实例字段。</li>
</ul>
<h2 id="增强类（Augmenting_Classes）">增强类（Augmenting Classes）</h2><p>JS的基于原型的继承机制是动态的：对象被创建后，原型变化也会影响这个对象。这意味着我们可以通过简单的添加新方法来增强类。</p>
<p>JS内置类也是开放的，你可以添加方法。</p>
<h2 id="类和类型（Classes_and_Types）">类和类型（Classes and Types）</h2><p>JS定义了一些类型（types）：null, undefined, boolean, number, string, function, object。</p>
<p><code>typeof</code>操作符可以区分这些类型。但是，把类当作对象的类型，并且以此区分对象可能更有用。JS内置对象（包括宿主对象）可以通过<code>Object.prototype.toString.call(obj).slice(8,-1);</code>来获取类名，但自定义对象则要通过本节介绍的一些方法来获取。</p>
<h3 id="instanceof操作符">instanceof操作符</h3><p><code>obj instanceof fun</code>，左边是对象，右边是构造函数，测试obj是否继承了fun的prototype。这种继承可以是间接的（多层继承）。</p>
<p>注意：构造函数是类的public identity，但原型才是最关键的。instanceof检查的是原型继承，而不是对象是否由该构造函数初始化。</p>
<p>如果你想测试原型链，可以用<code>prototypeObj.isPrototypeOf(obj)</code>。</p>
<p>这两个方法的缺点是无法知道对象的类名。而且在客户端（浏览器）中，多窗口和多框架子页面中web兼容性不佳。每个窗口和子页面都有单独的执行上下文，每个上下文都有独有的全局对象和一组构造函数：一个框架页面的数组instanceof另一个框架页面Array构造函数结果是false。</p>
<h3 id="构造函数属性（constructor_property）">构造函数属性（constructor property）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeAndValue</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// Null and undefined don't have constructors</span></span><br><span class="line">    <span class="keyword">switch</span>(x.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>: <span class="keyword">return</span> <span class="string">"Number: "</span> + x; <span class="comment">// Works for primitive types</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>: <span class="keyword">return</span> <span class="string">"String: '"</span> + x + <span class="string">"'"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>: <span class="keyword">return</span> <span class="string">"Date: "</span> + x; <span class="comment">// And for built-in types</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">RegExp</span>: <span class="keyword">return</span> <span class="string">"Regexp: "</span> + x;</span><br><span class="line">        <span class="keyword">case</span> Complex: <span class="keyword">return</span> <span class="string">"Complex: "</span> + x; <span class="comment">// And for user-defined types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的case后表达式都是函数，而typeof之类的返回值是字符串。</p>
<p>同instanceof一样，探测构造函数属性的方法没法在不同上下文下（不同框架页面、窗口）工作。另外，并非所有对象都有constructor属性，有的对象的constructor属性被覆盖，无法探测。</p>
<h3 id="构造函数名字（The_Constructor_Name）">构造函数名字（The Constructor Name）</h3><blockquote>
<p>The main problem with using the  instanceof operator or the  constructor property for determining the class of an object occurs when there are multiple execution contexts and thus multiple copies of the constructor functions. </p>
</blockquote>
<p>前面两种方法的一个重要缺陷是不同上下文时无法工作，所以我们可以尝试使用构造函数的名字而非构造函数本身。一些js实现（引擎）通过name属性让函数的名字可以被获取，而对一些没有name属性的JS实习来说，可以把函数转化为字符串，然后提取函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t, c, n; <span class="comment">// type, class, name</span></span><br><span class="line">    <span class="comment">// Special case for the null value:</span></span><br><span class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">    <span class="comment">// Another special case: NaN is the only value not equal to itself:</span></span><br><span class="line">    <span class="keyword">if</span> (o !== o) <span class="keyword">return</span> <span class="string">"nan"</span>;</span><br><span class="line">    <span class="comment">// Use typeof for any value other than "object".</span></span><br><span class="line">    <span class="comment">// This identifies any primitive value and also functions.</span></span><br><span class="line">    <span class="keyword">if</span> ((t = <span class="keyword">typeof</span> o) !== <span class="string">"object"</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="comment">// Return the class of the object unless it is "Object".</span></span><br><span class="line">    <span class="comment">// This will identify most native objects.</span></span><br><span class="line">    <span class="keyword">if</span> ((c = classof(o)) !== <span class="string">"Object"</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">// Return the object's constructor name, if it has one</span></span><br><span class="line">    <span class="keyword">if</span> (o.constructor &amp;&amp; <span class="keyword">typeof</span> o.constructor === <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">    (n = o.constructor.getName())) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// We can't determine a more specific type, so return "Object"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Object"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Return the class of an object.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Return the name of a function (may be "") or null for nonfunctions</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name = <span class="keyword">this</span>.toString().match(<span class="regexp">/function\s*([^(]*)\(/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数名字的方法仍然有问题，即不是所有对象都有constructor属性。另外，constructor属性的值可以是匿名函数。</p>
<h3 id="鸭式辨型（Duck-Typing）">鸭式辨型（Duck-Typing）</h3><p>上面的区分对象类型的方法都有问题（至少在客户端JS）。一个可替代方法是回避“what is the class of this object?”问题，转而回答 “what can this object do?”。</p>
<p>这种思考问题的方式与python和ruby很像，而Duck-Typing的称谓来源于这样一个表达：</p>
<blockquote>
<p>When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function for duck-type checking</span></span><br><span class="line"><span class="comment">// Return true if o implements the methods specified by the remaining args.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quacks</span>(<span class="params">o <span class="comment">/*, ... */</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123; <span class="comment">// for each argument after o</span></span><br><span class="line">        <span class="keyword">var</span> arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">typeof</span> arg) &#123; <span class="comment">// If arg is a:</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'string'</span>: <span class="comment">// string: check for a method with that name</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> o[arg] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'function'</span>: <span class="comment">// function: use the prototype object instead</span></span><br><span class="line">            <span class="comment">// If the argument is a function, we use its prototype object</span></span><br><span class="line">            arg = arg.prototype;</span><br><span class="line">            <span class="comment">// fall through to the next case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'object'</span>: <span class="comment">// object: check for matching methods</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">in</span> arg) &#123; <span class="comment">// For each property of the object</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg[m] !== <span class="string">"function"</span>) <span class="keyword">continue</span>; <span class="comment">// skip non-methods</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> o[m] !== <span class="string">"function"</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we're still here, then o implements everything</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JS中的面向对象技术">JS中的面向对象技术</h2><p>略</p>
<h2 id="子类（subclasses）">子类（subclasses）</h2><p>在面向对象编程语言中，类B可以继承类A，即A为父类，B为子类。<strong>类B的实例继承了类A的所有实例方法。</strong>类B也会定义自己的实例方法，可能会重载类A的同名方法。如果类B的一个方法重载了类A的方法，并且这个方法有时想要调用类A的被重载方法，这就叫方法链（method chaining）。同理，类B的构造函数B()可能会要调用类A构造函数A()，这就叫构造函数链（constructor chaining）。子类还可以有子类，在这种层级关系中，有时定义虚类会比较有用。虚类就是定义了一个或多个未实现的方法，方法的实现由继承虚类的类来完成。</p>
<p>创建子类的关键就是正确地初始化原型对象。如果B继承自A，那么B.prototype必须是A.prototype的后裔。</p>
<h3 id="定义子类（Defining_a_Subclass）">定义子类（Defining a Subclass）</h3><p>JS中，对象继承（类的）原型对象的属性（通常是方法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = inherit(A.prototype); <span class="comment">// Subclass inherits from superclass</span></span><br><span class="line">B.prototype.constructor = B;<span class="comment">// Override the inherited constructor prop.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">// p must be a non-null object</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="comment">// If Object.create() is defined...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p); <span class="comment">// then just use it.</span></span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p; <span class="comment">// Otherwise do some more type checking</span></span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// Define a dummy constructor function.</span></span><br><span class="line">    f.prototype = p; <span class="comment">// Set its prototype property to p.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// Use f() to create an "heir" of p.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple function for creating simple subclasses</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSubclass</span>(<span class="params">superclass, <span class="comment">// Constructor of the superclass</span></span><br><span class="line">                        constructor, <span class="comment">// The constructor for the new subclass</span></span><br><span class="line">                        methods,<span class="comment">// Instance methods: copied to prototype</span></span><br><span class="line">                        statics</span>)// <span class="title">Class</span> <span class="title">properties</span>: <span class="title">copied</span> <span class="title">to</span> <span class="title">constructor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// Set up the prototype object of the subclass</span></span><br><span class="line">    constructor.prototype = inherit(superclass.prototype);</span><br><span class="line">    constructor.prototype.constructor = constructor;</span><br><span class="line">    <span class="comment">// Copy the methods and statics as we would for a regular class</span></span><br><span class="line">    <span class="keyword">if</span> (methods) extend(constructor.prototype, methods);</span><br><span class="line">    <span class="keyword">if</span> (statics) extend(constructor, statics);</span><br><span class="line">    <span class="comment">// Return the class</span></span><br><span class="line">    <span class="keyword">return</span> constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和方法链（Constructor_and_Method_Chaining）">构造函数和方法链（Constructor  and Method Chaining）</h3><p>定义子类时，我们往往希望对父类的行为进行修改或扩充，而不是完全替换掉它们。为了做到这一点，构造函数或子类方法需要调用或链接到父类构造函数和父类方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NonNullSet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Just chain to our superclass.</span></span><br><span class="line">    <span class="comment">// Invoke the superclass constructor as an ordinary function to initialize</span></span><br><span class="line">    <span class="comment">// the object that has been created by this constructor invocation.</span></span><br><span class="line">    <span class="built_in">Set</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make NonNullSet a subclass of Set:</span></span><br><span class="line">NonNullSet.prototype = inherit(<span class="built_in">Set</span>.prototype);</span><br><span class="line">NonNullSet.prototype.constructor = NonNullSet;</span><br><span class="line"><span class="comment">// To exclude null and undefined, we only have to override the add() method</span></span><br><span class="line">NonNullSet.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Check for null or undefined arguments</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Can't add null or undefined to a NonNullSet"</span>);</span><br><span class="line">    <span class="comment">// Chain to the superclass to perform the actual insertion</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Set</span>.prototype.add.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="组合VS子类（Composition_Versus_Subclassing）">组合VS子类（Composition Versus Subclassing）</h3><p>一个广为人知的原则是“组合优于继承”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FilteredSet = <span class="built_in">Set</span>.extend(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FilteredSet</span>(<span class="params">set, filter</span>) </span>&#123; <span class="comment">// The constructor</span></span><br><span class="line">        <span class="keyword">this</span>.set = set;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="comment">// The instance methods</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// If we have a filter, apply it</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.filter) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.filter(v))</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"FilteredSet: value "</span> + v + <span class="string">" rejected by filter"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Now forward the add() method to this.set.add()</span></span><br><span class="line">            <span class="keyword">this</span>.set.add.apply(<span class="keyword">this</span>.set, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="类继承与虚类（Class_Hierarchies_and_Abstract_Classes）">类继承与虚类（Class Hierarchies and Abstract Classes）</h3>
        </div>
        
            <section id="comments">
                <div id="disqus_thread">
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                </div>
            </section>
        
    </div>
    <nav class="pagination-bar mdl-color-text--grey-50">
    
        <a href="/2014/09/angular-controller/" class="pagination__button">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900">
                <i class="material-icons">arrow_back</i>
            </button>
            Newer
        </a>
    
    <div class="section-spacer"></div>
    
        <a href="/2014/08/JavaScriptObject/" class="pagination__button">
            Older
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>
</div>
        </div>
    </main>
</div>

    <script>
        var disqus_shortname = 'ghblog-cp'; 
            var disqus_url = 'http://creeperyang.github.io/2014/08/classes-and-modules/'; 
        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>

        <script src="/assets/scripts/material.min.js" type="text/javascript"></script>
        
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63704729-1', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

    </body>
</html>